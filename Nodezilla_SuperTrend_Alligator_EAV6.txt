//+------------------------------------------------------------------+
//|                                         Nodezilla101_EA_BOT      |
//|                                                                  |
//| Automated trading bot using a triple-confirmation strategy.      |
//| Features smart SL/TP placement and instant Telegram alerts.      |
//|                                                                  |
//| Custom bots & advanced settings available upon request.          |
//| Contact: [+2348162150628] | [Nodezilla101@gmail.com]             |
//+------------------------------------------------------------------+
#property strict
#include <Trade/Trade.mqh>
CTrade Trade;

//================================================================================
input string   _A___Main_Strategy______ = "===== Main Strategy Inputs (Optimization Focus) =====";
//================================================================================
// --- Main Strategy ---
input ENUM_TIMEFRAMES TF_Trade        = PERIOD_H1;      // The timeframe the main strategy runs on.
input double         Risk_Percent     = 2.0;            // Risk % for main trades. Set to 0 to use Fixed_Lots.
input double         Fixed_Lots       = 0.20;           // Lot size for main trades if Risk_Percent is 0.
input double         RR_Min           = 1.5;            // MINIMUM R:R for main trades.
input double         RR_Max           = 3.0;            // MAXIMUM R:R for main trades.

// --- Main Strategy Filters ---
input bool           Use_HTF_Breakout_Filter = true;    // Require a breakout on a higher timeframe.
input ENUM_TIMEFRAMES TF_HTF_Breakout   = PERIOD_H2;    // Timeframe for the filter.
input ENUM_TIMEFRAMES TF_Main_Cancel_Gate  = PERIOD_H2; // Main trade pending orders Timeframe to watch.
input bool           Use_H1H4_Filter    = false;        // Require main trades to align with H1/H4 SuperTrend.
input bool           Use_ST_Flip_Retest = true;        // Wait for price to pull back to the ST line before entry.
input int            Max_Entry_Stages   = 4;            // Allow adding to a trade up to X times.
input int            Stage_Cooldown_Bars = 1;           // Bars to wait before adding next stage
input bool           One_Trade_At_A_Time = false;       // If true, only one main trade is allowed at a time.
input int            Cooldown_Bars    = 2;              // Bars to wait before opening a new Main trade

// --- Main Retracement & Pending Entry Settings ---
input bool           Use_Retrace_Limit_Entry = true;    // If true, adds a limit order on pullback.
input bool           Use_Pending_Stop_Entries = false;  // Use BUY_STOP/SELL_STOP instead of market orders.
input double         StopEntry_Offset_ATR = 0.2;        // ATR multiple to offset pending stop entry.
input int            StopEntry_Expiry_Bars = 18;        // How many bars a pending stop order is valid for.

// --- Main Indicator-Specific Settings ---
input double         AO_Min_Strength  = 1.0;            // Min AO strength for Main trades.
input double         Mom_Min_Strength    = 1.0;         // Required Momentum strength for Main trades.

// --- Main SL/TP Mechanics ---
input bool           Use_Fib_Targets    = true;         // Use Fibo-based TP for Main trades.
input bool           Use_RR_Range       = true;         // Use R:R range for Main trades.
input bool           Use_ST_as_Stop     = true;         // Use SuperTrend line as a dynamic stop loss.
input double         ST_Stop_Pad_Mult   = 0.3;          // ATR padding for the SuperTrend stop.
input double         TP_Max_ATR_Mult    = 10.0;         // Max TP size as an ATR multiple.
input double         TP_Swing_Ext_ATR_Mult = 0.5;      // TP swing extension ATR multiple.

// --- Main Filter Mechanics ---
input int            HTF_Breakout_Lookback = 200;       // Lookback for HTF breakout filter.
input int            HTF_Breakout_MaxAgeBars = 1;       // Max age of breakout signal.
input double         Retest_ATR_Tolerance = 1.25;       // ATR tolerance for ST retest.
input double         AddEntry_Trigger_Ratio = 0.2;      // % pullback towards SL to allow adding a new stage.
input int            Min_Bars_After_Flip = 4;           // Bars to wait after ST flip before retest entry.
input double         Confirm_Close_Dist_ATR = 0.20;     // Min distance from ST line to confirm retest.
input bool           Require_Retrace_Or_Breakout = true; // Require entry to be a retrace or breakout.
input double         Breakout_ATR_Margin = 1.40;        // ATR margin for main trade breakout.

//================================================================================
input string   _B___Scalp_Strategy______ = "===== Scalp Strategy Inputs (Optimization Focus) =====";
//================================================================================

// --- Scalp Strategy ---
input bool           Use_Scalp_Mode   = true;           // scalping engine on/off.
input ENUM_TIMEFRAMES TF_Scalp        = PERIOD_M10;     // scalp strategy timeframe.
input bool           Scalp_Use_Fixed_Lot = false;       // true = use fixed lot below, false = use risk %
input double         Fixed_Lots_Scalp = 0.20;           // scalp trades Lot size.
input double         Risk_Percent_Scalp = 2.0;          // if >0, overrides and uses this absolute % just for scalps
input double         Scalp_Risk_Mult    = 2.0;          // Multiplies main Risk % if Risk_Percent_Scalp is 0.
input double         Scalp_RR_Min     = 1.5;            // MINIMUM R:R for scalp trades.
input double         Scalp_RR_Max     = 3.0;            // MAXIMUM R:R for scalp trades.

// --- Scalp Strategy Filters ---
input bool           Scalp_Gate_By_HTF  = true;         // Require scalp trades to align with HTF breakout.
input ENUM_TIMEFRAMES TF_Scalp_Gate_HTF = PERIOD_M20;   // scalp alignment filter Timeframe.
input ENUM_TIMEFRAMES TF_Scalp_Cancel_Gate = PERIOD_M20; // Scalp trade pending orders Timeframe to watch.
input bool           Scalp_Only_When_No_Main = false;   // Block scalps if a main trade is already open.
input int            Scalp_Max_Concurrent = 4;          // Max number of simultaneous scalp trades.
input double         Scalp_Gate_ATR_Margin = 0.60;      // ATR margin for scalp HTF gate.

// --- Scalp Pending Order Mechanics ---
input int            Scalp_StopEntry_Expiry_Bars = 30;  // Expiry for scalp limit orders.
input double         Scalp_Market_Entry_ATR_Zone = 0.5; // ATR zone around Alligator Lips for market entry.

// --- Scalp Indicator-Specific Settings ---
input double         AO_Scalp_Min_Strength = 1.0;       // Min AO strength for Scalp trades.
input double         Mom_Scalp_Min_Strength = 0.5;      // Required Momentum strength for scalps.
input int            Scalp_ATR_Period   = 14;            // ATR Period for scalp SL/TP calculation.

// --- Scalp SL/TP Mechanics ---
input bool           Scalp_Use_RR_Range = true;         // Use R:R range for Scalp trades.
input double         Scalp_TP_Max_ATR_Mult = 3.0;       // Max TP for scalps.
input double         Scalp_TP_Swing_Ext_ATR_Mult = 1.0; // TP swing extension for scalps.
input double         Scalp_SL_ATR_Mult  = 1.0;          // SL ATR multiple for scalps.
input bool           Protect_Scalp_SLTP = false;        // Prevent trade management (BE, Trail) from modifying scalp trades.

//================================================================================
input string   _C___Shared_Settings______ = "===== Shared Settings (Entries, Exits & Filters) =====";
//================================================================================
// ==== NEW CONSOLIDATION INPUTS ====
input bool Use_Auto_Regime_Switch = true;   // If true, switches to Scalp when H4, H1, or M15 is flat.
input double         Consol_H4_ADX_Min      = 20.0;   // H4: Below this = Dead Trend
input double         Consol_H1_BB_Width     = 0.0020; // H1: Below this = Squeeze (0.0020 = 0.2%)
input double         Consol_M15_Range_Pts   = 150.0;  // M15: Max Points range to be considered "Chop"

// --- General Entry Filters (Shared) ---
input bool           Cancel_Pending_On_Flip = false;     // Cancel pending orders if SuperTrend flips.
input bool           Use_OverboughtOversold_Filter = true; // Block entries in extreme WPR zones.
input double         WPR_Overbought_Level          = -25.0; // Level above which buys are blocked.
input double         WPR_Oversold_Level            = -85.0; // Level below which sells are blocked.
input bool           Use_Anti_Chasing_Filter = true;   // NEW: Block entries if > X% to TP
input double         Anti_Chasing_Filter_Percent = 55.0;// Block entries if > X% to TP
input bool           Use_Breakout_Confirmation   = true; // Require a sequence of candles to confirm a breakout.
input int            Required_Confirmation_Candles = 2; // Number of follow-up candles required (2 or 3).
input double         Breakout_Min_Body_ATR_Mult = 0.2;  // Body must be > 20% of ATR

// --- Proactive & Emergency Exits (Shared) ---
input bool           Use_Momentum_Exit_Filter = true;   // If true, exits on signs of trend exhaustion (divergence).
input int            Divergence_Lookback_Bars = 15;     // How many bars to check for divergence.
input double         Momentum_Exit_Min_TP_Percent = 60.0; // Trigger Momentum Exit only if > X% to TP
input bool           Use_Volatility_CircuitBreaker = true; // Emergency brake for extreme volatility.
input double         CircuitBreaker_ATR_Mult = 2.0;     // Closes all if a candle is > X times the average size.

// --- Trailing Stops (Shared) ---
input bool           Use_ATR_Trailing   = true;         // Dynamic SL that follows price based on volatility.
input int            ATR_Period_Trail   = 10;           // <-- ATR period for the trailing stop
input double         ATR_Trail_Mult     = 2;          // Multiplier for ATR Trail. Higher = wider trail.
input bool           Use_HalfStep_Trailing = false;     // Alternative trail: SL moves half the distance to TP.
input bool           HalfTrail_NewBar_Only = true;      // <-- Only update half-step on new bars

// --- Break-Even (Shared) ---
input double         BE_Activation_TP_Percent = 10.0;    // Move SL to BE when trade is X% of the way to TP.
input double         BE_Profit_Percent        = 1.5;    // lock in at BE profit (as % of TP).
input double         BE_Buffer_Points         = 300.0;  // Profit gap in points for BE (e.g., 100)

// --- Partial Close & TP Management (Shared) ---
input bool           Use_Partial_Close         = true;  // Enable partial closing near TP
input double         Partial_Close_TP_Percent  = 80.0;  // Trigger partial close at X% of the way to TP
input double         Partial_Close_Volume_Percent = 50.0; // Close X% of the position volume
input bool           Use_Dynamic_TP_Tighten = true;     // Tighten TP if momentum weakens
input double         TP_Pullback_ATR_Mult = 0.3;        // NEW: Pulls TP back by this ATR multiple. Set to 0 to disable.

// --- Trading Session Timer (Shared) ---
input bool           Use_Time_Filter   = false;         // true = Only trade during the session below
input int            Trade_Start_Hour  = 9;             // Start hour (server time, e.g., 9)
input int            Trade_Start_Min   = 0;             // Start minute (e.g., 0)
input int            Trade_End_Hour    = 17;            // End hour (server time, e.g., 17)
input int            Trade_End_Min     = 0;             // End minute (e.g., 0)

// --- Indicator Confirmation Toggles (Shared) ---
input bool Use_Alligator_Filter = true;                 // Use Alligator state for confirmation
input bool Use_AO_Filter = true;                       // Use Awesome Oscillator strength for confirmation
input bool Use_Momentum_Filter = true;                 // true = require Momentum confirmation
input bool Use_WPR_Filter = true;                      // Use WPR for signals & filters (MASTER)

// --- Core Indicator Settings (Shared) ---
input int            ST_ATR_Period    = 14;             // SuperTrend ATR Period
input double         ST_ATR_Mult      = 2.0;            // SuperTrend ATR Multiplier
input int            Jaw_Period       = 6;             // Alligator Jaw Period
input int            Jaw_Shift        = 10;
input int            Teeth_Period     = 10;              // Alligator Teeth Period
input int            Teeth_Shift      = 1;
input int            Lips_Period      = 4;              // Alligator Lips Period
input int            Lips_Shift       = 1;
input int            Momentum_Period     = 10;          // Period for the Momentum indicator
input int            Mom_StdDev_Period = 20;            // Lookback for Momentum Volatility (StdDev)
input bool           Use_WPR_Bias     = true;           // Use WPR -50 line bias filter.
input bool           Use_WPR_Cross    = false;          // Use WPR cross-over signals.

// --- Detailed SL/TP Mechanics (Shared) ---
input bool           Use_Dynamic_SL_ATR = true;         // Use dynamic ATR-based SL calculation.
input double         ATR_SL_Buffer_Mult = 0.1;          // Small padding for swing-based SL.
input double         SL_ATR_Min         = 2.5;          // Minimum SL size as ATR multiple.
input double         SL_ATR_Max         = 4.5;          // Maximum SL size as ATR multiple.
input double         SL_Swing_Pad_ATR   = 0.3;          // Padding beyond swing point for dynamic SL.
input double         Min_SL_ATR_Mult    = 0.75;         // Absolute minimum SL in ATR.
input int            Min_SL_Points      = 0;            // Absolute minimum SL in points.

//================================================================================
input string   _D___System_And_Maintenance______ = "===== System & Maintenance Inputs (Set & Forget) =====";
//================================================================================
// --- General ---
input bool           Auto_Trade       = true;           // MASTER SWITCH: true = place trades, false = signals only
input bool           Inp_Trading_Enabled  = true;       // MASTER SWITCH: true = place trades, false = signals only

//---- Telegram ----
input string          TG_BOT_TOKEN         = "7282987011:AAEhNJa4-dxTcD6WAlSULezrbO3JtDg85t8";
input string          TG_CHAT_ID           = "-1002073947481";
input long            TG_THREAD_ID         = 333;
input string          My_Command_Name       = "Trending"; // Set this once (if needed)
input string          Opposite_Command_Name = "Ranging";  // Set this once

// --- Manual Trade Management ---
input bool           ApplyToManualTrades = true;        // Apply BE/Trail/Exit logic to manual trades
input bool           Manual_Set_Initial_SLTP = true;    // Add SL/TP to manual trades
input bool           Manual_Use_Fib_Targets = true;
input bool           Manual_Use_RR_Range = true;
input double         Manual_RR_Min      = 1.5;
input double         Manual_RR_Max      = 10.0;
input double         Manual_TP_Max_ATR_Mult = 2.5;
input double         Manual_TP_Swing_Ext_ATR_Mult = 1.5;

// --- System & Housekeeping ---
input bool           Adjust_All_Exclude_Scalps = true;  // Stop sync logic from affecting scalps.
input bool           Adjust_All_To_Latest = true;       // Sync SL/TP of all trades to the newest one.
input long           Magic_Main       = 250925;         // Magic for Main strategy
input long           Magic_Scalp      = 250927;         // Magic for Scalp strategy
input int            Slippage_Points  = 60;             // Allowed slippage
input bool           Send_Closed_Trade_Alerts = true;

// --- Alert Toggles ---
input bool           Send_Weekly_Report = true;
input int            Weekly_Report_DOW = 0;
input int            Weekly_Report_Hour = 22;
input int            Weekly_Report_Min = 0;
input bool           Send_Monthly_Report = true;
input int            Monthly_Report_DOM = 1;
input int            Monthly_Report_Hour = 22;
input int            Monthly_Report_Min = 0;

//============================== Globals =============================
datetime lastTradeBarTime = 0;
bool Trading_Enabled = true; // This will be our new master switch
// --- Retest/stack state
int      prevDir_ST   = 0;    // previous ST dir on M15
datetime flipBar      = 0;    // bar time when ST flipped
int      stageCount   = 0;    // 0=none, 1=main, 2/3=added retests
datetime lastStageBar = 0;    // bar time of last stage entry
datetime g_lastWeeklyReportSent  = 0;
datetime g_lastMonthlyReportSent = 0;
long     g_lastUpdateID = 0; // Tracks the last processed Telegram command
// ADD THIS NEW GLOBAL VARIABLE
datetime g_eaStartTime;
bool g_trailingActivated = false; // NEW: Flag to track if BE or Trailing has started
bool g_breakoutConfirmed = false; // NEW: Flag to track if a clean breakout is confirmed for the current trend
ulong g_partialClosedTickets[]; // Array to track tickets that have been partially closed
bool sent = false;
int      g_marketRetracePlacedDir = 0; // +1=Buy, -1=Sell, 0=None for Retrace Market Entry
bool reduceTP = false;
ENUM_TIMEFRAMES signalTF = PERIOD_CURRENT; // or your preferred timeframe
int weaknessScore = 0;

//============================== Utils ===============================
string tfstr(ENUM_TIMEFRAMES tf)
{
    switch(tf)
    {
        case PERIOD_M1:   return "M1";
        case PERIOD_M5:   return "M5";
        case PERIOD_M15:  return "M15";
        case PERIOD_M30:  return "M30";
        case PERIOD_H1:   return "H1";
        case PERIOD_H4:   return "H4";
        case PERIOD_D1:   return "D1";
    }
    return "TF";
}

// Drop-in replacement for your SendTG(...) - Now supports Topics/Threads
bool SendTG(const string msg)
{
    // 1. Stop immediately if running in Strategy Tester
    if(MQLInfoInteger(MQL_TESTER)) return true;

    if(StringLen(TG_BOT_TOKEN)<10 || StringLen(TG_CHAT_ID)<1) return false;
    
    string url = "https://api.telegram.org/bot"+(string)TG_BOT_TOKEN+"/sendMessage";
    string body = "chat_id="+(string)TG_CHAT_ID
    + "&parse_mode=HTML&disable_web_page_preview=1"
    + "&text="+URLEncode(msg);
    
    if (TG_THREAD_ID != 0) body += "&message_thread_id=" + (string)TG_THREAD_ID;
    
    char post[];
    StringToCharArray(body, post, 0, WHOLE_ARRAY, CP_UTF8);
    char result[];
    string resp_headers;
    
    int res = WebRequest("POST", url, "Content-Type: application/x-www-form-urlencoded\r\n", 5000, post, result, resp_headers);
    
    if(res==-1) {
        // Only print error if NOT in tester (double check)
        if(!MQLInfoInteger(MQL_TESTER))
            Print("WebRequest error: ", GetLastError());
        return false;
    }
    return true;
}

// URL-encode for Telegram (UTF-8 ‚Üí %XX)
string URLEncode(const string s)
{
    uchar bytes[];
    StringToCharArray(s, bytes, 0, WHOLE_ARRAY, CP_UTF8);
    string out="";
    for(int i=0;i<ArraySize(bytes);i++)
    {
        uchar c = bytes[i];
        bool safe = ( (c>='a' && c<='z') || (c>='A' && c<='Z') ||
                     (c>='0' && c<='9') || c=='-' || c=='_' || c=='.' || c=='~' );
        if(safe) out += StringFormat("%c", c);
        else if(c==' ') out += "%20";
        else out += StringFormat("%%%02X", c);
    }
    return out;
}

// Function to process Telegram commands - UPGRADED FOR SYMBOL SPECIFICITY
void ProcessTelegramCommand(string command)
{
    // 1. Clean up the command string
    StringTrimLeft(command);
    StringTrimRight(command);
    
    // 2. Split the command by spaces to find arguments
    // Example: "/onTrending Boom1000" -> ["/onTrending", "Boom1000"]
    string parts[];
    int count = StringSplit(command, ' ', parts);
    
    if(count <= 0) return;
    
    // The first part is the command (e.g., "/onTrending")
    string incoming_cmd = parts[0];
    
    // The second part (optional) is the Symbol/Pair
    string target_symbol = "";
    // Find the first non-empty argument after the command
    for(int i = 1; i < ArraySize(parts); i++)
    {
        if(parts[i] != "")
        {
            target_symbol = parts[i];
            break;
        }
    }
    
    // --- Build expected base commands ---
    string cmd_my_on     = "/on" + My_Command_Name;
    string cmd_my_off    = "/off" + My_Command_Name;
    string cmd_my_status = "/status" + My_Command_Name;
    
    string cmd_opposite_on = "/on" + Opposite_Command_Name;
    
    // --- SYMBOL FILTER LOGIC ---
    // If the user typed a pair name (e.g. "Boom1000"), check if it matches THIS chart.
    // If it doesn't match, we IGNORE the command.
    if(target_symbol != "" && target_symbol != "ALL")
    {
        // Compare target_symbol with _Symbol (Case Insensitive)
        if(StringCompare(target_symbol, _Symbol, false) != 0)
        {
            // The command is for a different pair (e.g., Gold), so we do nothing.
            return;
        }
    }
    
    // --- Execute Commands ---
    
    // 1. Turn THIS EA ON
    if(incoming_cmd == cmd_my_on)
    {
        Trading_Enabled = true;
        SendTG("üü¢ " + My_Command_Name + " trading ENABLED on " + _Symbol);
    }
    
    // 2. Turn THIS EA OFF
    else if(incoming_cmd == cmd_my_off)
    {
        Trading_Enabled = false;
        SendTG("üî¥ " + My_Command_Name + " trading DISABLED on " + _Symbol);
    }
    
    // 3. SAFETY: OPPOSITE EA ON -> THIS EA OFF
    else if(incoming_cmd == cmd_opposite_on)
    {
        if(Trading_Enabled)
        {
            Trading_Enabled = false;
            SendTG("üî¥ " + My_Command_Name + " auto-DISABLED on " + _Symbol + " (" + Opposite_Command_Name + " activated).");
        }
    }
    
    // 4. Status Check
    else if(incoming_cmd == cmd_my_status || incoming_cmd == "/statusall")
    {
         string status = Trading_Enabled ? "üü¢ ENABLED" : "üî¥ DISABLED";
         SendTG("üìä " + My_Command_Name + " Status (" + _Symbol + "): " + status);
    }
}

// NEW FUNCTION: Clean up partial closed tickets array
void CleanupPartialClosedTickets()
{
    // Remove tickets for positions that no longer exist
    for(int i = ArraySize(g_partialClosedTickets) - 1; i >= 0; i--)
    {
        ulong ticket = g_partialClosedTickets[i];
        bool positionExists = false;
        
        // Check if position still exists
        for(int p = 0; p < PositionsTotal(); p++)
        {
            ulong posTicket = PositionGetTicket(p);
            if(posTicket == ticket)
            {
                positionExists = true;
                break;
            }
        }
        
        // Remove from array if position doesn't exist
        if(!positionExists)
        {
            ArrayRemove(g_partialClosedTickets, i, 1);
        }
    }
    
    // Limit array size to prevent memory issues (keep last 100)
    if(ArraySize(g_partialClosedTickets) > 100)
    {
        ArrayCopy(g_partialClosedTickets, g_partialClosedTickets, 0, ArraySize(g_partialClosedTickets) - 100, 100);
        ArrayResize(g_partialClosedTickets, 100);
    }
}

// --- Helper function to check if we are within the allowed trading session ---
bool IsTradeTime()
{
    if (!Use_Time_Filter) return true;
    
    MqlDateTime now;
    TimeCurrent(now); // Gets SERVER time, not local time
    
    // DEBUG: Print this to the journal/comment so you can see it!
    // PrintFormat("Server Time: %02d:%02d", now.hour, now.min);

    int currentHour = now.hour;
    int currentMin  = now.min;
    
    int startTime = Trade_Start_Hour * 60 + Trade_Start_Min;
    int endTime   = Trade_End_Hour   * 60 + Trade_End_Min;
    int currentTime = currentHour * 60 + currentMin;
    
    bool isAllowed = false;
    if (startTime <= endTime)
    {
        if (currentTime >= startTime && currentTime < endTime) isAllowed = true;
    }
    else
    {
        if (currentTime >= startTime || currentTime < endTime) isAllowed = true;
    }
    
    return isAllowed;
}

//+------------------------------------------------------------------+
//| OnTimer() - NEW FUNCTION                                         |
//| This function runs every 60 seconds to check for new commands.   |
//+------------------------------------------------------------------+
void OnTimer()
{
    // Fetch and process any new Telegram commands
    FetchTelegramUpdates();
}

//+------------------------------------------------------------------+
//| FetchTelegramUpdates() - NEW FUNCTION                            |
//| Polls the Telegram API for new messages.                         |
//+------------------------------------------------------------------+
void FetchTelegramUpdates()
{
    // 1. Stop immediately if running in Strategy Tester
    if(MQLInfoInteger(MQL_TESTER)) return;

    if(StringLen(TG_BOT_TOKEN) < 10 || StringLen(TG_CHAT_ID) < 1) return;
    
    string url = "https://api.telegram.org/bot" + (string)TG_BOT_TOKEN +
    "/getUpdates?chat_id=" + (string)TG_CHAT_ID + "&limit=1&offset=-1";
    
    char post[]; char result[]; string resp_headers;
    int res = WebRequest("GET", url, NULL, NULL, 5000, post, 0, result, resp_headers);
    
    if(res == -1) return; // Fail silently
    
    string response = CharArrayToString(result);
    if(StringLen(response) == 0) return;
    
    long new_update_id = 0;
    string command_text = "";
    
    if(GetLastCommand(response, new_update_id, command_text))
    {
        if(new_update_id > g_lastUpdateID)
        {
            g_lastUpdateID = new_update_id;
            ProcessTelegramCommand(command_text);
        }
    }
}

//+------------------------------------------------------------------+
//| GetLastCommand() - NEW HELPER FUNCTION                           |
//| A simple parser to find the update_id and text from JSON.        |
//+------------------------------------------------------------------+
bool GetLastCommand(string response, long &update_id, string &command)
{
    // Find the last "update_id"
    int last_update_pos = StringFind(response, "\"update_id\":", 0);
    if(last_update_pos == -1) return false;
    
    // Find the number after it
    int id_start = last_update_pos + 12;
    int id_end = StringFind(response, ",", id_start);
    if(id_end == -1) id_end = StringFind(response, "}", id_start);
    if(id_end == -1) return false;
    
    string id_str = StringSubstr(response, id_start, id_end - id_start);
    update_id = (long)id_str;
    
    // Find the last "text" field
    int last_text_pos = StringFind(response, "\"text\":\"", 0);
    if(last_text_pos == -1) return false;
    
    int cmd_start = last_text_pos + 8;
    int cmd_end = StringFind(response, "\"", cmd_start);
    if(cmd_end == -1) return false;
    
    command = StringSubstr(response, cmd_start, cmd_end - cmd_start);
    return true;
}
//======================== Indicator Helpers =========================

double MomentumValue(ENUM_TIMEFRAMES tf, int shift=1)
{
    int h = iMomentum(_Symbol, tf, Momentum_Period, PRICE_CLOSE);
    if(h==INVALID_HANDLE) return 100.0;
    double mom[];
    ArraySetAsSeries(mom,true);
    if(CopyBuffer(h,0,0,shift+3,mom)<=shift){ IndicatorRelease(h); return 100.0; }
    double v = mom[shift];
    IndicatorRelease(h);
    return v;
}

// Function 1: Detects divergence for proactive EXITS
bool CheckMomentumDivergence(long tradeType, int lookbackBars, ENUM_TIMEFRAMES tf)
{
    if (!Use_AO_Filter && !Use_Momentum_Filter) {
        return false;
    }
    if(lookbackBars < 2) return false;
    
    MqlRates prices[];
    if(CopyRates(_Symbol, tf, 0, lookbackBars, prices) < lookbackBars) return false;
    ArraySetAsSeries(prices, true);
    
    int hAO = INVALID_HANDLE;
    double ao_buffer[]; ArraySetAsSeries(ao_buffer, true);
    if (Use_AO_Filter) {
        hAO = iAO(_Symbol, tf);
        if(hAO == INVALID_HANDLE) { }
        else if(CopyBuffer(hAO, 0, 0, lookbackBars, ao_buffer) < lookbackBars) {
            IndicatorRelease(hAO);
            hAO = INVALID_HANDLE;
        }
    }
    
    int hMom = iMomentum(_Symbol, tf, Momentum_Period, PRICE_CLOSE);
    if(hMom == INVALID_HANDLE) {
        if (hAO != INVALID_HANDLE) IndicatorRelease(hAO);
        return false;
    }
    double mom_buffer[]; ArraySetAsSeries(mom_buffer, true);
    if(CopyBuffer(hMom, 0, 0, lookbackBars, mom_buffer) < lookbackBars) {
        if (hAO != INVALID_HANDLE) IndicatorRelease(hAO);
        IndicatorRelease(hMom);
        return false;
    }
    
    if(tradeType == POSITION_TYPE_BUY)
    {
        int highest_high_index = -1;
        double highest_high_price = 0;
        for(int i = 1; i < lookbackBars; i++) {
            if(prices[i].high > highest_high_price) {
                highest_high_price = prices[i].high;
                highest_high_index = i;
            }
        }
        if(highest_high_index != -1) {
            bool price_makes_new_high = (prices[0].high > highest_high_price);
            bool ao_momentum_is_lower  = Use_AO_Filter && (ao_buffer[0] < ao_buffer[highest_high_index]);
            bool mom_momentum_is_lower = (mom_buffer[0] < mom_buffer[highest_high_index]);
            
            if(price_makes_new_high && (mom_momentum_is_lower || ao_momentum_is_lower)) {
                IndicatorRelease(hAO);
                IndicatorRelease(hMom);
                return true;
            }        }
    }
    else
    {
        int lowest_low_index = -1;
        double lowest_low_price = 9999999;
        for(int i = 1; i < lookbackBars; i++) {
            if(prices[i].low < lowest_low_price) {
                lowest_low_price = prices[i].low;
                lowest_low_index = i;
            }
        }
        if(lowest_low_index != -1) {
            bool price_makes_new_low = (prices[0].low < lowest_low_price);
            bool ao_momentum_is_higher  = Use_AO_Filter && (ao_buffer[0] > ao_buffer[lowest_low_index]);
            bool mom_momentum_is_higher = (mom_buffer[0] > mom_buffer[lowest_low_index]);
            
            if(price_makes_new_low && (mom_momentum_is_higher || ao_momentum_is_higher)) {
                IndicatorRelease(hAO);
                IndicatorRelease(hMom);
                return true;
            }
        }
    }
    
    if (hAO != INVALID_HANDLE) IndicatorRelease(hAO);
    IndicatorRelease(hMom);
    return false;
}

// UPGRADED FUNCTION: Adds a limit order at a calculated SuperTrend retest point.
void ManageRetraceLimitOrders()
{
    if (!Use_Retrace_Limit_Entry) return;
    
    int stopOrders = CountPendingThisEA();
    int limitOrders = CountPendingLimitOrdersThisEA();
    
    if (stopOrders <= limitOrders)
    {
        return;
    }
    
    ulong  stop_order_ticket = 0;
    long   stop_order_type = 0;
    double stop_order_sl = 0;
    double stop_order_tp = 0;
    datetime newest_time = 0;
    
    for (int i = 0; i < OrdersTotal(); i++)
    {
        if (OrderSelect(OrderGetTicket(i)))
        {
            long orderMagic = OrderGetInteger(ORDER_MAGIC);
            if ((orderMagic == Magic_Main) && OrderGetString(ORDER_SYMBOL) == _Symbol)
            {
                long type = OrderGetInteger(ORDER_TYPE);
                if (type == ORDER_TYPE_BUY_STOP || type == ORDER_TYPE_SELL_STOP)
                {
                    datetime place_time = (datetime)OrderGetInteger(ORDER_TIME_SETUP);
                    if (place_time > newest_time)
                    {
                        newest_time = place_time;
                        stop_order_ticket = OrderGetTicket(i);
                        stop_order_type = type;
                        stop_order_sl = OrderGetDouble(ORDER_SL);
                        stop_order_tp = OrderGetDouble(ORDER_TP);
                    }
                }
            }
        }
    }
    
    if (stop_order_ticket == 0 || stop_order_sl <= 0 || stop_order_tp <= 0) return;
    
    double limit_price = 0;
    if(!FindRetraceEntryWithinRange(stop_order_type, stop_order_sl, stop_order_tp, limit_price))
    {
        return;
    }
    
    double new_sl = 0, new_tp = 0;
    bool isBuy = (stop_order_type == ORDER_TYPE_BUY_STOP);
    
    double pH, pL, atr;
    if(!GetSwingsATR(TF_Main_Cancel_Gate, 300, ST_ATR_Period, pH, pL, atr)) return;
    if(!BuildSLTP_FromSwings(isBuy, limit_price, pH, pL, atr, Use_Fib_Targets, RR_Min, new_sl, new_tp)) return;
    
    double lots = LotsByRisk(Risk_Percent, MathAbs(limit_price - new_sl) / _Point);
    if(lots <= 0) lots = Fixed_Lots;
    
    ENUM_ORDER_TYPE_TIME time_type = Cancel_Pending_On_Flip ? ORDER_TIME_GTC : ORDER_TIME_SPECIFIED;
    datetime expiration = Cancel_Pending_On_Flip ? 0 : TimeCurrent() + (StopEntry_Expiry_Bars * PeriodSeconds(TF_Trade));
    
    if(isBuy)
    {
        Trade.BuyLimit(lots, limit_price, _Symbol, new_sl, new_tp, time_type, expiration, "V25 Buy Retrace Limit");
    }
    else
    {
        Trade.SellLimit(lots, limit_price, _Symbol, new_sl, new_tp, time_type, expiration, "V25 Sell Retrace Limit");
    }
}

//+------------------------------------------------------------------+
//| Executes a Market Order if price touches the M15 ST line.        |
//+------------------------------------------------------------------+
void ManageRetraceMarketEntry()
{
    if (!Auto_Trade) return;
    if (!IsTradeTime()) return;
    if (g_marketRetracePlacedDir != 0) return;
    
    double st_main_line;
    int    st_main_dir;
    if (!CalcSuperTrend(TF_Trade, ST_ATR_Period, ST_ATR_Mult, 1, st_main_line, st_main_dir))
        return;
    
    if (st_main_dir != g_marketRetracePlacedDir)
    {
        g_marketRetracePlacedDir = 0;
    }
    
    if (g_marketRetracePlacedDir != 0 || st_main_dir == 0)
        return;
    
    double st_retrace_line;
    int    st_retrace_dir;
    if (!CalcSuperTrend(TF_Main_Cancel_Gate, ST_ATR_Period, ST_ATR_Mult, 1, st_retrace_line, st_retrace_dir))
        return;
    
    if (st_main_dir != st_retrace_dir)
        return;
    
    double currentHigh = iHigh(_Symbol, TF_Main_Cancel_Gate, 0);
    double currentLow  = iLow(_Symbol, TF_Main_Cancel_Gate, 0);
    
    bool touch = false;
    bool isBuy = (st_main_dir > 0);
    
    if (isBuy && currentLow <= st_retrace_line)
    {
        touch = true;
    }
    else if (!isBuy && currentHigh >= st_retrace_line)
    {
        touch = true;
    }
    
    if (!touch)
        return;
    
    if(One_Trade_At_A_Time && CountOpen() > 0)
    {
        return;
    }
    
    double pH_main, pL_main, atr_main;
    if (!GetSwingsATR(TF_Trade, 300, ST_ATR_Period, pH_main, pL_main, atr_main))
        return;
    if (atr_main <= 0.0)
        return;
    
    double new_sl = 0.0, new_tp = 0.0;
    double entryPrice = isBuy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    if(isBuy)
    {
        if(Use_Dynamic_SL_ATR) { if(!PickSL_DynamicATR(true, entryPrice, atr_main, pH_main, pL_main, SL_ATR_Min, SL_ATR_Max, SL_Swing_Pad_ATR, new_sl)) return; }
        else { new_sl = pL_main - ATR_SL_Buffer_Mult * atr_main; }
        
        if(Use_ST_as_Stop) { double stPad = ST_Stop_Pad_Mult * atr_main; new_sl = MathMin(new_sl, st_main_line - stPad); }
        
        bool tpOk=false;
        if(Use_RR_Range) { double chosenR=0, dynTP=0; tpOk = PickRRTarget(true, entryPrice, new_sl, atr_main, pH_main, pL_main, RR_Min, RR_Max, TP_Max_ATR_Mult, TP_Swing_Ext_ATR_Mult, chosenR, dynTP); if(tpOk) new_tp = dynTP; }
        if(!tpOk) { double leg = MathAbs(pH_main - pL_main); new_tp = pH_main + 2.618 * leg; }
    }
    else
    {
        if(Use_Dynamic_SL_ATR) { if(!PickSL_DynamicATR(false, entryPrice, atr_main, pH_main, pL_main, SL_ATR_Min, SL_ATR_Max, SL_Swing_Pad_ATR, new_sl)) return; }
        else { new_sl = pH_main + ATR_SL_Buffer_Mult * atr_main; }
        
        if(Use_ST_as_Stop) { double stPad = ST_Stop_Pad_Mult * atr_main; new_sl = MathMax(new_sl, st_main_line + stPad); }
        
        bool tpOk=false;
        if(Use_RR_Range) { double chosenR=0, dynTP=0; tpOk = PickRRTarget(false, entryPrice, new_sl, atr_main, pH_main, pL_main, RR_Min, RR_Max, TP_Max_ATR_Mult, TP_Swing_Ext_ATR_Mult, chosenR, dynTP); if(tpOk) new_tp = dynTP; }
        if(!tpOk) { double leg = MathAbs(pH_main - pL_main); new_tp = pL_main - 2.618 * leg; }
    }
    
    SanitizeStops(isBuy ? POSITION_TYPE_BUY : POSITION_TYPE_SELL, new_sl, new_tp);
    
    if (isBuy && (entryPrice - new_sl <= 0 || new_tp <= entryPrice)) return;
    if (!isBuy && (new_sl - entryPrice <= 0 || new_tp >= entryPrice)) return;
    
    double riskPts = isBuy ? (entryPrice - new_sl) / _Point : (new_sl - entryPrice) / _Point;
    
    if (riskPts <= MinStopPoints()) return;
    
    double lots = LotsByRisk(Risk_Percent, riskPts);
    if(lots <= 0) lots = Fixed_Lots;
    
    string comment = isBuy ? "V25 Buy Retrace Market" : "V25 Sell Retrace Market";
    Trade.SetExpertMagicNumber(Magic_Main);
    bool orderSent = false;
    
    if(isBuy)
    {
        Trade.Buy(lots, _Symbol, entryPrice, new_sl, new_tp, comment);
        orderSent = (Trade.ResultRetcode() == TRADE_RETCODE_DONE);
    }
    else
    {
        Trade.Sell(lots, _Symbol, entryPrice, new_sl, new_tp, comment);
        orderSent = (Trade.ResultRetcode() == TRADE_RETCODE_DONE);
    }
    
    if (orderSent)
    {
        g_marketRetracePlacedDir = st_main_dir;
        SendTG(StringFormat("‚úÖ Market Retrace %s placed at %.5f (M15 ST Touch)", isBuy ? "BUY" : "SELL", entryPrice));
        lastTradeBarTime = iTime(_Symbol, TF_Trade, 0);
    }
    else
    {
        SendTG(StringFormat("‚ùå Market Retrace %s failed: ret=%d", isBuy ? "BUY" : "SELL", Trade.ResultRetcode()));
    }
}

// NEW HELPER FUNCTION: Finds a valid SuperTrend retest entry within a given price range.
bool FindRetraceEntryWithinRange(long tradeType, double rangeBottom, double rangeTop, double &retracePriceOut)
{
    double st_line;
    int st_dir;
    if (!CalcSuperTrend(TF_Main_Cancel_Gate, ST_ATR_Period, ST_ATR_Mult, 1, st_line, st_dir))
    {
        return false;
    }
    
    bool isBuy = (tradeType == ORDER_TYPE_BUY_STOP);
    
    if (isBuy && st_dir > 0)
    {
        if (st_line > rangeBottom && st_line < SymbolInfoDouble(_Symbol, SYMBOL_ASK))
        {
            retracePriceOut = st_line;
            return true;
        }
    }
    else if (!isBuy && st_dir < 0)
    {
        if (st_line < rangeTop && st_line > SymbolInfoDouble(_Symbol, SYMBOL_BID))
        {
            retracePriceOut = st_line;
            return true;
        }
    }
    
    return false;
}

// NEW, UPGRADED FUNCTION: Manages pending orders based on their type (Main vs. Scalp).
void ManagePendingOrders()
{
    if (!Cancel_Pending_On_Flip) return;
    
    double st_main_line;
    int st_main_dir;
    if (!CalcSuperTrend(TF_Main_Cancel_Gate, ST_ATR_Period, ST_ATR_Mult, 1, st_main_line, st_main_dir)) return;
    
    double st_scalp_line;
    int st_scalp_dir;
    if (!CalcSuperTrend(TF_Scalp_Cancel_Gate, ST_ATR_Period, ST_ATR_Mult, 1, st_scalp_line, st_scalp_dir)) return;
    
    for (int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if (OrderSelect(ticket))
        {
            long orderMagic = OrderGetInteger(ORDER_MAGIC);
            if (OrderGetString(ORDER_SYMBOL) == _Symbol &&
                (orderMagic == Magic_Main || orderMagic == Magic_Scalp))
            {
                long   orderType = OrderGetInteger(ORDER_TYPE);
                bool   isScalp   = (orderMagic == Magic_Scalp);
                
                int relevantST_dir = isScalp ? st_scalp_dir : st_main_dir;
                ENUM_TIMEFRAMES relevant_TF = isScalp ? TF_Scalp_Cancel_Gate : TF_Main_Cancel_Gate;
                
                bool isBuyOrder  = (orderType == ORDER_TYPE_BUY_STOP || orderType == ORDER_TYPE_BUY_LIMIT);
                bool isSellOrder = (orderType == ORDER_TYPE_SELL_STOP || orderType == ORDER_TYPE_SELL_LIMIT);
                
                if ((isBuyOrder && relevantST_dir < 0) || (isSellOrder && relevantST_dir > 0))
                {
                    Trade.OrderDelete(ticket);
                    if (Trade.ResultRetcode() == TRADE_RETCODE_DONE)
                    {
                        SendTG(StringFormat("‚ö†Ô∏è <b>PENDING ORDER CANCELED</b>\n\n"
                                            "üìä <b>Symbol:</b> %s\n"
                                            "‚ö° <b>Reason:</b> Trend flipped on %s.",
                                            _Symbol, tfstr(relevant_TF)));
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Adaptive Breakout Confirmation (V3 - Stricter Body Check)        |
//+------------------------------------------------------------------+
bool IsCleanBreakout(long tradeType, int requiredCandles, ENUM_TIMEFRAMES tf)
{
    MqlRates rates[];
    if (CopyRates(_Symbol, tf, 0, requiredCandles + 3, rates) < requiredCandles + 3)
    {
        PrintFormat("DEBUG Breakout: insufficient bars for %s", _Symbol);
        return false;
    }
    ArraySetAsSeries(rates, true);
    
    double atr = 0.0;
    int hATR = iATR(_Symbol, tf, ST_ATR_Period);
    if (hATR != INVALID_HANDLE)
    {
        double a[];
        ArraySetAsSeries(a, true);
        if (CopyBuffer(hATR, 0, 0, 3, a) > 1)
            atr = a[1];
        IndicatorRelease(hATR);
    }
    
    double minBodySize = atr * Breakout_Min_Body_ATR_Mult;
    
    double avgCandle = 0.0;
    for (int i = 1; i <= requiredCandles; i++)
        avgCandle += (rates[i].high - rates[i].low);
    avgCandle /= requiredCandles;
    
    bool highVol = (atr > avgCandle * 1.5);
    int adaptiveCandles = highVol ? MathMax(2, requiredCandles) : 1;
    
    PrintFormat("DEBUG Breakout: ATR=%.5f avgCandle=%.5f highVol=%s adaptiveCandles=%d MinBody=%.5f",
                atr, avgCandle, highVol ? "true" : "false", adaptiveCandles, minBodySize);
    
    for (int i = 1; i <= adaptiveCandles; i++)
    {
        double bodySize = MathAbs(rates[i].close - rates[i].open);
        
        if (tradeType == POSITION_TYPE_BUY)
        {
            if (rates[i].close < rates[i].open || (bodySize < minBodySize && minBodySize > 0))
            {
                PrintFormat("DEBUG Breakout Blocked: Candle[%d] was BEARISH or body (%.5f) < min (%.5f)",
                            i, bodySize, minBodySize);
                return false;
            }
        }
        else if (tradeType == POSITION_TYPE_SELL)
        {
            if (rates[i].close > rates[i].open || (bodySize < minBodySize && minBodySize > 0))
            {
                PrintFormat("DEBUG Breakout Blocked: Candle[%d] was BULLISH or body (%.5f) < min (%.5f)",
                            i, bodySize, minBodySize);
                return false;
            }
        }
    }
    
    PrintFormat("DEBUG Breakout Confirmed: %s direction=%s adaptiveCandles=%d",
                _Symbol,
                (tradeType == POSITION_TYPE_BUY ? "BUY" : "SELL"),
                adaptiveCandles);
    return true;
}

// ---- Dynamic SL: pick SL at [min..max] ATRs from entry, and beyond swing by pad
bool PickSL_DynamicATR(bool isBuy,
                       double entry, double atr,
                       double swingHigh, double swingLow,
                       double minATR, double maxATR,
                       double padATR,
                       double &slOut)
{
    if(atr<=0.0) return false;
    double minDist = minATR*atr;
    double maxDist = maxATR*atr;
    
    double base = isBuy ?
    (swingLow  - padATR*atr)
    : (swingHigh + padATR*atr);
    
    double d = MathAbs(entry - base);
    if(isBuy){
        if(base>=entry) base = entry - minDist;
        d = MathAbs(entry - base);
        if(d<minDist) base = entry - minDist;
        else if(d>maxDist) base = entry - maxDist;
    }else{
        if(base<=entry) base = entry + minDist;
        d = MathAbs(entry - base);
        if(d<minDist) base = entry + minDist;
        else if(d>maxDist) base = entry + maxDist;
    }
    
    slOut = base;
    return true;
}

// ---- Dynamic TP: choose R in [rrMin..rrMax] limited by ATR cap and swing "room"
bool PickRRTarget(bool isBuy,
                  double entry, double sl, double atr,
                  double lastHigh, double lastLow,
                  double rrMin, double rrMax,
                  double tpMaxATRs, double swingExtATRs,
                  double &chosenR, double &tpOut)
{
    if(atr<=0.0) return false;
    double risk = MathAbs(entry - sl);
    if(risk<=0.0) return false;
    
    double rCapATR = (tpMaxATRs*atr) / risk;
    
    double capPrice = isBuy ?
    (lastHigh + swingExtATRs*atr)
    : (lastLow  - swingExtATRs*atr);
    double room     = isBuy ?
    MathMax(0.0, capPrice - entry)
    : MathMax(0.0, entry - capPrice);
    double rCapSwing = (room>0.0) ?
    (room / risk) : 0.0;
    
    double rFeasible = (rCapSwing>0.0) ? MathMin(rCapATR, rCapSwing) : rCapATR;
    if(rFeasible<=0.0) return false;
    chosenR = MathMin(rrMax, rFeasible);
    if(chosenR < rrMin) return false;
    
    tpOut = isBuy ? (entry + chosenR*risk) : (entry - chosenR*risk);
    return true;
}

// Find last swing high/low on a TF (reuses your fractal logic)
bool GetLastSwingsTF(ENUM_TIMEFRAMES tf, int lookback, double &pHigh, double &pLow, int &barHigh, int &barLow)
{
    int hFr = iFractals(_Symbol, tf);
    if(hFr==INVALID_HANDLE) return false;
    double up[], dn[];
    ArraySetAsSeries(up,true); ArraySetAsSeries(dn,true);
    if(CopyBuffer(hFr,0,0,lookback,up)<=0 || CopyBuffer(hFr,1,0,lookback,dn)<=0){ IndicatorRelease(hFr); return false; }
    
    barHigh=-1; pHigh=0.0; barLow=-1; pLow=0.0;
    for(int i=2; i<lookback; ++i)
    {
        if(up[i]!=EMPTY_VALUE && barHigh==-1){ barHigh=i; pHigh=up[i]; }
        if(dn[i]!=EMPTY_VALUE && barLow==-1){ barLow=i; pLow=dn[i]; }
        if(barHigh!=-1 && barLow!=-1) break;
    }
    IndicatorRelease(hFr);
    return (barHigh!=-1 && barLow!=-1);
}

bool TrendlineAt(ENUM_TIMEFRAMES tf, int lookback, bool bull, int shift, double &linePx)
{
    int hFr = iFractals(_Symbol, tf);
    if(hFr==INVALID_HANDLE) return false;
    double up[], dn[];
    ArraySetAsSeries(up,true); ArraySetAsSeries(dn,true);
    if(CopyBuffer(hFr,0,0,lookback,up)<=0 || CopyBuffer(hFr,1,0,lookback,dn)<=0){ IndicatorRelease(hFr); return false; }
    
    // collect two most recent pivots of the required side
    int i1=-1,i2=-1; double p1=0.0,p2=0.0;
    for(int i=2; i<lookback; ++i)
    {
        double v = bull ? dn[i] : up[i];
        if(v!=EMPTY_VALUE){
            if(i1==-1){ i1=i; p1=v; }
            else { i2=i; p2=v; break; }
        }
    }
    IndicatorRelease(hFr);
    if(i1==-1 || i2==-1 || i1==i2) return false;
    
    // line through (i1,p1) and (i2,p2) in "bars as x"
    double slope = (p2 - p1) / (double)(i2 - i1);
    linePx = p1 + slope * (double)(shift - i1);
    return true;
}
// Test for "strong" HTF breakout within last N bars.
bool IsStrongBreakoutHTF(ENUM_TIMEFRAMES tf, int lookback, int atrPeriod,
                         double atrMargin, int modeAND_1_else_OR_0, int maxAgeBars,
                         int &dirOut, int &ageOut)
{
    dirOut=0; ageOut=0;
    
    int hATR = iATR(_Symbol, tf, atrPeriod);
    if(hATR==INVALID_HANDLE) return false;
    double a[]; ArraySetAsSeries(a,true);
    if(CopyBuffer(hATR,0,0,maxAgeBars+3,a) <= maxAgeBars){ IndicatorRelease(hATR); return false; }
    
    double pH=0.0, pL=0.0; int bH=-1,bL=-1;
    if(!GetLastSwingsTF(tf, lookback, pH, pL, bH, bL)){ IndicatorRelease(hATR); return false; }
    
    for(int s=1; s<=maxAgeBars; ++s)
    {
        double c = iClose(_Symbol, tf, s);
        double atr = a[s];
        
        bool srBuy  = (c >= pH + atrMargin*atr);
        bool srSell = (c <= pL - atrMargin*atr);
        
        double tlBull=0.0, tlBear=0.0;
        bool tlB = TrendlineAt(tf, lookback, true,  s, tlBull);
        bool tlS = TrendlineAt(tf, lookback, false, s, tlBear);
        
        bool tlBuy  = tlB && (c >= tlBull + atrMargin*atr);
        bool tlSell = tlS && (c <= tlBear - atrMargin*atr);
        
        bool buyOK  = tlBuy;
        bool sellOK = tlSell;
        
        if(buyOK){ dirOut=+1; ageOut=s; IndicatorRelease(hATR); return true; }
        if(sellOK){ dirOut=-1; ageOut=s; IndicatorRelease(hATR); return true; }
    }
    IndicatorRelease(hATR);
    return false;
}

// --- MIN distance (stop+freeze) in points
int  MinStopPoints() {
    int stop   = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
    int freeze = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_FREEZE_LEVEL);
    return MathMax(stop, freeze);
}

// Get Alligator lines at a shift
bool GetAlligatorLines(ENUM_TIMEFRAMES tf, int shift, double &jawOut, double &teethOut, double &lipsOut)
{
    int h=iAlligator(_Symbol, tf, Jaw_Period, Jaw_Shift, Teeth_Period, Teeth_Shift, Lips_Period, Lips_Shift, MODE_SMMA, PRICE_MEDIAN);
    if(h==INVALID_HANDLE) return false;
    double jaw[], teeth[], lips[]; ArraySetAsSeries(jaw,true); ArraySetAsSeries(teeth,true); ArraySetAsSeries(lips,true);
    bool ok=true;
    if(CopyBuffer(h,0,0,shift+2,jaw)<=shift)   ok=false;
    if(CopyBuffer(h,1,0,shift+2,teeth)<=shift) ok=false;
    if(CopyBuffer(h,2,0,shift+2,lips)<=shift)  ok=false;
    IndicatorRelease(h);
    if(!ok) return false;
    jawOut=jaw[shift]; teethOut=teeth[shift]; lipsOut=lips[shift];
    return true;
}

// Alligator state:  +1 bull, -1 bear, 0 neutral
int AlligatorState(ENUM_TIMEFRAMES tf, int shift=1)
{
    int h = iAlligator(_Symbol, tf, Jaw_Period, Jaw_Shift, Teeth_Period, Teeth_Shift, Lips_Period, Lips_Shift, MODE_SMMA, PRICE_MEDIAN);
    if(h==INVALID_HANDLE) return 0;
    
    double jaw[], teeth[], lips[];
    ArraySetAsSeries(jaw,true);  ArraySetAsSeries(teeth,true);  ArraySetAsSeries(lips,true);
    if(CopyBuffer(h,0,0,shift+5,jaw)<=shift)  { IndicatorRelease(h); return 0; }
    if(CopyBuffer(h,1,0,shift+5,teeth)<=shift){ IndicatorRelease(h); return 0; }
    if(CopyBuffer(h,2,0,shift+5,lips)<=shift) { IndicatorRelease(h); return 0; }
    
    double c = iClose(_Symbol,tf,shift);
    int state = 0;
    if(lips[shift] > teeth[shift] && teeth[shift] > jaw[shift] && c > jaw[shift]) state = +1;
    else if(lips[shift] < teeth[shift] && teeth[shift] < jaw[shift] && c < jaw[shift]) state = -1;
    
    IndicatorRelease(h);
    return state;
}

// AO value
double AOValue(ENUM_TIMEFRAMES tf, int shift=1)
{
    int h = iAO(_Symbol, tf);
    if(h==INVALID_HANDLE) return 0.0;
    double ao[];
    ArraySetAsSeries(ao,true);
    if(CopyBuffer(h,0,0,shift+3,ao)<=shift){ IndicatorRelease(h); return 0.0; }
    double v = ao[shift];
    IndicatorRelease(h);
    return v;
}

// WPR value ([-100..0]) -> e.g. -20, -50, -80
double WPRValue(ENUM_TIMEFRAMES tf, int shift=1)
{
    int h = iWPR(_Symbol, tf, 14);
    if(h==INVALID_HANDLE) return -50.0;
    double w[];
    ArraySetAsSeries(w,true);
    if(CopyBuffer(h,0,0,shift+3,w)<=shift){ IndicatorRelease(h); return -50.0; }
    double v = w[shift];
    IndicatorRelease(h);
    return v;
}

// SuperTrend calc (dir: +1 up, -1 down). Returns line at 'shift'.
bool CalcSuperTrend(ENUM_TIMEFRAMES tf, int atrPeriod, double mult, int shift, double &stLine, int &dir)
{
    const int want= atrPeriod + 200;
    MqlRates rates[];
    ArraySetAsSeries(rates,true);
    int got = CopyRates(_Symbol, tf, 0, want, rates);
    if(got < atrPeriod+5) return false;
    
    int hATR = iATR(_Symbol, tf, atrPeriod);
    if(hATR==INVALID_HANDLE) return false;
    double atr[];
    ArraySetAsSeries(atr,true);
    if(CopyBuffer(hATR,0,0,got,atr)<=0){ IndicatorRelease(hATR); return false; }
    
    static double upper[], lower[], fUp[], fDn[];
    static int    trend[];
    ArrayResize(upper,got); ArrayResize(lower,got);
    ArrayResize(fUp,got);   ArrayResize(fDn,got);
    ArrayResize(trend,got);
    
    for(int idx=got-1; idx>=0; --idx)
    {
        double median = (rates[idx].high + rates[idx].low)*0.5;
        upper[idx] = median + mult * atr[idx];
        lower[idx] = median - mult * atr[idx];
        
        if(idx==got-1)
        {
            fUp[idx] = upper[idx];
            fDn[idx] = lower[idx];
            trend[idx] = +1;
            continue;
        }
        
        fUp[idx] = MathMin(upper[idx], fUp[idx+1]);
        fDn[idx] = MathMax(lower[idx], fDn[idx+1]);
        
        int curTrend = trend[idx+1];
        double prevUp = fUp[idx+1];
        double prevDn = fDn[idx+1];
        
        if(rates[idx].close > prevUp) curTrend = +1;
        else if(rates[idx].close < prevDn) curTrend = -1;
        
        if(curTrend==+1) fUp[idx] = upper[idx];
        else             fDn[idx] = lower[idx];
        
        trend[idx] = curTrend;
    }
    
    dir = trend[shift];
    stLine = (dir>0) ? fDn[shift] : fUp[shift];
    
    IndicatorRelease(hATR);
    return true;
}

bool GetSwingsATR(ENUM_TIMEFRAMES tf, int lookback, int atrPeriod,
                  double &pHigh, double &pLow, double &atrOut)
{
    int barHigh, barLow;
    double ph, pl;
    if(!RecentSwings(tf, lookback, barHigh, ph, barLow, pl)) return false;
    
    int hATR = iATR(_Symbol, tf, atrPeriod);
    if(hATR==INVALID_HANDLE) return false;
    double a[]; ArraySetAsSeries(a,true);
    if(CopyBuffer(hATR,0,0,3,a)<2){ IndicatorRelease(hATR); return false; }
    atrOut = a[1];
    IndicatorRelease(hATR);
    
    pHigh = ph;
    pLow  = pl;
    return true;
}

bool BuildSLTP_FromSwings(bool isBuy, double entry, double pHigh, double pLow, double atr,
                          bool useFib, double rr, double &sl, double &tp)
{
    if(isBuy)
    {
        sl = pLow - ATR_SL_Buffer_Mult * atr;
        if(useFib){
            double leg = MathAbs(pHigh - pLow);
            tp = pHigh + 1.618 * leg;
        }else{
            double riskPts = (entry - sl)/_Point;
            if(riskPts<=0) return false;
            tp = entry + rr * riskPts * _Point;
        }
    }
    else
    {
        sl = pHigh + ATR_SL_Buffer_Mult * atr;
        if(useFib){
            double leg = MathAbs(pHigh - pLow);
            tp = pLow - 1.618 * leg;
        }else{
            double riskPts = (sl - entry)/_Point;
            if(riskPts<=0) return false;
            tp = entry - rr * riskPts * _Point;
        }
    }
    return (sl>0 && tp>0);
}

// Find recent swing high/low using fractals
bool RecentSwings(ENUM_TIMEFRAMES tf, int lookback, int &barHigh, double &priceHigh, int &barLow, double &priceLow)
{
    int hFr = iFractals(_Symbol, tf);
    if(hFr==INVALID_HANDLE) return false;
    
    double up[], dn[];
    ArraySetAsSeries(up,true); ArraySetAsSeries(dn,true);
    if(CopyBuffer(hFr,0,0,lookback,up)<=0 || CopyBuffer(hFr,1,0,lookback,dn)<=0){ IndicatorRelease(hFr); return false; }
    
    barHigh=-1; priceHigh=0; barLow=-1; priceLow=0;
    for(int i=2; i<lookback; ++i)
    {
        if(up[i]!=EMPTY_VALUE && barHigh==-1){ barHigh=i; priceHigh=up[i]; }
        if(dn[i]!=EMPTY_VALUE && barLow==-1){ barLow=i; priceLow=dn[i]; }
        if(barHigh!=-1 && barLow!=-1) break;
    }
    IndicatorRelease(hFr);
    return (barHigh!=-1 && barLow!=-1);
}

//============================== Position/Risk Management Utilities (Called by Core Logic) =========================

// MODIFIED FUNCTION: Closes all positions and only alerts if closes occurred
void EmergencyCloseAllPositions(const string reason)
{
    int positionsClosedCount = 0;
    
    ulong tickets[];
    int totalPositions = PositionsTotal();
    
    for(int i = 0; i < totalPositions; i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0)
        {
            int size = ArraySize(tickets);
            ArrayResize(tickets, size + 1);
            tickets[size] = ticket;
        }
    }
    
    for(int i = 0; i < ArraySize(tickets); i++)
    {
        if(PositionSelectByTicket(tickets[i]))
        {
            if(PositionGetString(POSITION_SYMBOL) == _Symbol)
            {
                // --- NEW SELECTIVE LOGIC ---
                
                // 1. Check if the trade is in profit ("market goes my way")
                bool isInProfit = (PositionGetDouble(POSITION_PROFIT) > 0.0);
                
                // 2. Check if any trailing stop system is enabled in settings
                bool isTrailEnabled = (Use_ATR_Trailing || Use_HalfStep_Trailing);

                // 3. Check if the global trail flag has been set (meaning BE or Trail has moved at least once)
                bool isTrailActive = isTrailEnabled && g_trailingActivated;

                //
                // IF the trade is in profit OR a trailing stop is active, SKIP CLOSING.
                //
                if (isInProfit || isTrailActive)
                {
                    // Uncomment the line below if you want an alert
                    // SendTG("üîî Breaker skipped for ticket #" + (string)tickets[i] + ". Trade is in profit or being trailed.");
                    continue; // Skip this ticket, let it run
                }
                
                // --- END SELECTIVE LOGIC ---

                // If we are here, the trade is NOT in profit AND NOT being trailed. Close it.
                if(Trade.PositionClose(tickets[i], 10))
                {
                    if(Trade.ResultRetcode() == TRADE_RETCODE_DONE || Trade.ResultRetcode() == TRADE_RETCODE_PLACED)
                    {
                        positionsClosedCount++;
                    }
                }
            }
        }
    }
    
    if (positionsClosedCount > 0)
    {
        string alertMsg = StringFormat(
                                       "üö® <b>CIRCUIT BREAKER TRIPPED</b> üö®\n\n"
                                       "üìä <b>Symbol:</b> %s\n"
                                       "‚ö° <b>Reason:</b> %s\n\n"
                                       "<i>%d position(s) have been closed to prevent further loss.</i>",
                                       _Symbol, reason, positionsClosedCount
                                       );
        SendTG(alertMsg);
    }
}

// NEW FUNCTION: Syncs all open stops to the latest SL, but only if it's an improvement
void SyncAllStopsSafely(double latestSL)
{
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if((string)PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
        
        long   type    = PositionGetInteger(POSITION_TYPE);
        double currentSL = PositionGetDouble(POSITION_SL);
        double currentTP = PositionGetDouble(POSITION_TP);
        double modSL = currentSL;
        
        if(type == POSITION_TYPE_BUY && latestSL > currentSL)
        {
            modSL = latestSL;
        }
        else if(type == POSITION_TYPE_SELL && latestSL < currentSL)
        {
            modSL = latestSL;
        }
        
        if(modSL != currentSL)
        {
            Trade.PositionModify(ticket, modSL, currentTP);
        }
    }
}

void TouchUpManualInitial()
{
    if(!ApplyToManualTrades || !Manual_Set_Initial_SLTP) return;
    
    int total = PositionsTotal();
    for(int i=0;i<total;i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string sym = (string)PositionGetString(POSITION_SYMBOL);
        if(sym != _Symbol) continue;
        
        long magic = PositionGetInteger(POSITION_MAGIC);
        if(magic != 0) continue;
        
        long   type  = PositionGetInteger(POSITION_TYPE);
        double entry = PositionGetDouble(POSITION_PRICE_OPEN);
        double sl    = PositionGetDouble(POSITION_SL);
        double tp    = PositionGetDouble(POSITION_TP);
        
        bool needSL = (sl<=0.0);
        bool needTP = (tp<=0.0);
        if(!needSL && !needTP) continue;
        
        double pH,pL,atr;
        if(!GetSwingsATR(TF_Trade, 300, ST_ATR_Period, pH, pL, atr)) continue;
        
        double newSL = sl, newTP = tp;
        bool isBuy   = (type==POSITION_TYPE_BUY);
        
        if(needSL || needTP)
        {
            double tmpSL, tmpTP;
            if(!BuildSLTP_FromSwings(isBuy, entry, pH, pL, atr,
                                     Manual_Use_Fib_Targets, Manual_RR_Min, tmpSL, tmpTP))
                continue;
            
            if(needSL) newSL = tmpSL;
            if(needTP) newTP = tmpTP;
            
            if(PositionSelect(sym))
            {
                long ptype = PositionGetInteger(POSITION_TYPE);
                
                if(!MathIsValidNumber(newSL)) newSL = 0.0;
                if(!MathIsValidNumber(newTP)) newTP = 0.0;
                
                double modSL = newSL;
                double modTP = newTP;
                SanitizeStops(ptype, modSL, modTP);
                
                double curSL = PositionGetDouble(POSITION_SL);
                double curTP = PositionGetDouble(POSITION_TP);
                bool changed = ( (modSL>0 && MathAbs(modSL-curSL) >= 0.5*_Point) ||
                                (modTP>0 && MathAbs(modTP-curTP) >= 0.5*_Point) );
                
                Trade.PositionModify(_Symbol, modSL, modTP);
                if (Trade.ResultRetcode() == TRADE_RETCODE_DONE)
                {
                    SendTG(StringFormat("‚ö° Manual %s on %s: set %s%s\nSL: %.2f  TP: %.2f",
                                        isBuy?"BUY":"SELL", _Symbol,
                                        needSL?"SL ":"", needTP?"TP":"", modSL, modTP));
                }
            }
        }
    }
}

// Apply one SL/TP to ALL open (EA+manual) trades in that direction
void ApplySLTPToAllOpen(int dir, double newSL, double newTP)
{
    for(int i=0;i<PositionsTotal();++i){
        ulong tk=PositionGetTicket(i);
        if(!PositionSelectByTicket(tk)) continue;
        if((string)PositionGetString(POSITION_SYMBOL)!=_Symbol) continue;
        long typ=PositionGetInteger(POSITION_TYPE);
        int d=(typ==POSITION_TYPE_BUY)?+1:-1;
        if(d!=dir) continue;
        
        string pcomment = (string)PositionGetString(POSITION_COMMENT);
        if(Adjust_All_Exclude_Scalps && StringFind(pcomment, "Scalp", 0) >= 0) continue;
        
        double curSL=PositionGetDouble(POSITION_SL);
        double curTP=PositionGetDouble(POSITION_TP);
        double modSL=newSL, modTP=newTP;
        SanitizeStops(typ, modSL, modTP);
        
        bool changed=( (modSL>0 && MathAbs(modSL-curSL)>=0.5*_Point) ||
                      (modTP>0 && MathAbs(modTP-curTP)>=0.5*_Point) );
        if(changed) Trade.PositionModify(_Symbol, modSL, modTP);
    }
}

// Latest open position (EA or manual) in given direction (+1 buy, -1 sell)
bool GetLatestOpenPos(int dir, bool includeManual, ulong &ticketOut, double &entryOut, double &slOut)
{
    datetime newest=0; bool found=false;
    for(int i=0;i<PositionsTotal();++i){
        ulong tk=PositionGetTicket(i);
        if(!PositionSelectByTicket(tk)) continue;
        if((string)PositionGetString(POSITION_SYMBOL)!=_Symbol) continue;
        long typ=PositionGetInteger(POSITION_TYPE);
        int d=(typ==POSITION_TYPE_BUY)?+1:-1;
        if(d!=dir) continue;
        long mg=PositionGetInteger(POSITION_MAGIC);
        if(!(mg==Magic_Main || mg==Magic_Scalp || (includeManual && mg==0))) continue;
        datetime t=(datetime)PositionGetInteger(POSITION_TIME);
        if(t>newest){ newest=t; found=true; ticketOut=tk;
            entryOut=PositionGetDouble(POSITION_PRICE_OPEN);
            slOut   =PositionGetDouble(POSITION_SL);
        }
    }
    return found;
}

// Has price reached a % of the way from entry to SL (toward SL)?
bool ReachedRatioToSL(int dir, double entry, double sl, double ratio)
{
    if(sl<=0.0) return false;
    double bid=SymbolInfoDouble(_Symbol,SYMBOL_BID);
    double ask=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
    double cur=(dir>0)?bid:ask;
    if(dir>0){ double risk=entry-sl; if(risk<=0) return false; return (entry-cur)>=ratio*risk; }
    else     { double risk=sl-entry; if(risk<=0) return false; return (cur-entry)>=ratio*risk; }
}

// --- Make SL/TP finite, correct side of price, and beyond min distance (V2)
void SanitizeStops(long posType, double &sl, double &tp)
{
    if(!MathIsValidNumber(sl) || sl==EMPTY_VALUE) sl = 0.0;
    if(!MathIsValidNumber(tp) || tp==EMPTY_VALUE) tp = 0.0;
    
    const int    digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
    const double bid    = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    const double ask    = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    const double mind   = (double)MinStopPoints() * _Point;
    
    const double buffer = _Point * 2;
    
    if(posType==POSITION_TYPE_BUY)
    {
        if(sl>0 && sl >= bid - mind) sl = bid - mind - buffer;
        if(tp>0 && tp <= ask + mind) tp = ask + mind + buffer;
        
        if(sl >= bid) sl = 0.0;
        if(tp <= ask) tp = 0.0;
    }
    else
    {
        if(sl>0 && sl <= ask + mind) sl = ask + mind + buffer;
        if(tp>0 && tp >= bid - mind) tp = bid - mind - buffer;
        
        if(sl <= ask) sl = 0.0;
        if(tp >= bid) tp = 0.0;
    }
    
    if(sl>0) sl = NormalizeDouble(sl, digits);
    if(tp>0) tp = NormalizeDouble(tp, digits);
}

double NormalizeVolume(double v){
    double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    double minv = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxv = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    if(step<=0) step=0.01;
    v = MathFloor(v/step)*step;
    if(v<minv) v=minv;
    if(v>maxv) v=maxv;
    return v;
}

// ==== ADD PARTIAL CLOSE FUNCTIONS RIGHT HERE ====

// Add this helper function to check if a ticket is in the partial closed array
bool IsTicketPartiallyClosed(ulong ticket)
{
    for(int i = 0; i < ArraySize(g_partialClosedTickets); i++)
    {
        if(g_partialClosedTickets[i] == ticket)
            return true;
    }
    return false;
}

// Add this helper function to add a ticket to the partial closed array
void AddToPartialClosed(ulong ticket)
{
    int size = ArraySize(g_partialClosedTickets);
    ArrayResize(g_partialClosedTickets, size + 1);
    g_partialClosedTickets[size] = ticket;
}

// Add this function to handle partial closing
void CheckPartialClose(ulong ticket, long type, double entry, double sl, double tp, double volume, string comment)
{
    if(!Use_Partial_Close) return;
    if(IsTicketPartiallyClosed(ticket)) return;
    
    double currentPrice = (type == POSITION_TYPE_BUY) ?
    SymbolInfoDouble(_Symbol, SYMBOL_BID) :
    SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    
    double progress = 0.0;
    if(type == POSITION_TYPE_BUY)
    {
        if(tp > entry && currentPrice > entry)
        {
            progress = (currentPrice - entry) / (tp - entry) * 100.0;
        }
    }
    else
    {
        if(tp < entry && currentPrice < entry)
        {
            progress = (entry - currentPrice) / (entry - tp) * 100.0;
        }
    }
    
    if(progress >= Partial_Close_TP_Percent)
    {
        double closeVolume = volume * (Partial_Close_Volume_Percent / 100.0);
        closeVolume = NormalizeVolume(closeVolume);
        
        double minVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
        if(closeVolume >= minVolume && closeVolume < volume)
        {
            Trade.PositionClosePartial(ticket, closeVolume);
            if (Trade.ResultRetcode() == TRADE_RETCODE_DONE)
            {
                AddToPartialClosed(ticket);
                
                string msg = StringFormat(
                                          "üìä <b>PARTIAL CLOSE EXECUTED</b>\n\n"
                                          "üìä <b>Symbol:</b> %s\n"
                                          "üî¢ <b>Ticket:</b> %I64u\n"
                                          "üìà <b>Type:</b> %s\n"
                                          "‚ö° <b>Progress to TP:</b> %.1f%%\n"
                                          "üì¶ <b>Volume Closed:</b> %.2f lots (%.1f%%)\n"
                                          "üéØ <b>Remaining Volume:</b> %.2f lots\n"
                                          "üí¨ <b>Comment:</b> %s",
                                          _Symbol,
                                          ticket,
                                          (type == POSITION_TYPE_BUY) ? "BUY" : "SELL",
                                          progress,
                                          closeVolume,
                                          Partial_Close_Volume_Percent,
                                          volume - closeVolume,
                                          comment
                                          );
                SendTG(msg);
            }
        }
    }
}

// Compute lot size by risk percent and SL points (simplified, Deriv synthetics)
double LotsByRisk(double riskPct, double slPoints)
{
    if(riskPct<=0.0 || slPoints<=0.0) return Fixed_Lots;
    double bal = AccountInfoDouble(ACCOUNT_BALANCE);
    double riskMoney = bal * (riskPct/100.0);
    double tv = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    double tp = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    if(tp<=0 || tv<=0) return Fixed_Lots;
    double valuePerPointPerLot = tv / tp;
    double lots = riskMoney / (slPoints * valuePerPointPerLot);
    double step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    double minv = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxv = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    lots = MathMax(minv, MathMin(maxv, MathFloor(lots/step)*step));
    if(lots<=0) lots = minv;
    return lots;
}

// Count open positions by this EA for current symbol
int CountOpen()
{
    int total = PositionsTotal();
    int cnt=0;
    for(int p=0; p<total; ++p)
    {
        ulong ticket = PositionGetTicket(p);
        if(PositionSelectByTicket(ticket))
        {
            long magic = PositionGetInteger(POSITION_MAGIC);
            if((magic==Magic_Main || magic==Magic_Scalp) && (string)PositionGetString(POSITION_SYMBOL)==_Symbol)
                cnt++;
        }
    }
    return cnt;
}

// Count open SCALP positions by this EA for current symbol
int CountOpenScalp()
{
    int count = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(PositionSelectByTicket(PositionGetTicket(i)))
        {
            if(PositionGetString(POSITION_SYMBOL) != _Symbol)
                continue;
            
            long magic = PositionGetInteger(POSITION_MAGIC);
            if(magic == Magic_Scalp)
            {
                count++;
            }
        }
    }
    return count;
}

int CountOpenMain()
{
    int count = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(PositionSelectByTicket(PositionGetTicket(i)))
        {
            if(PositionGetString(POSITION_SYMBOL) != _Symbol)
                continue;
            
            long magic = PositionGetInteger(POSITION_MAGIC);
            if(magic == Magic_Main)
            {
                count++;
            }
        }
    }
    return count;
}

// Count pending orders from this EA for this symbol
int CountPendingThisEA()
{
    int c=0;
    for(int i=0;i<OrdersTotal();++i)
    {
        ulong ticket = OrderGetTicket(i);
        if(ticket==0) continue;
        if(!OrderSelect(ticket)) continue;
        
        if((string)OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        long magic = (long)OrderGetInteger(ORDER_MAGIC);
        if(magic != Magic_Main) continue;
        
        long t = (long)OrderGetInteger(ORDER_TYPE);
        if(t==ORDER_TYPE_BUY_STOP || t==ORDER_TYPE_SELL_STOP) c++;
    }
    return c;
}

// Count pending LIMIT orders from this EA for this symbol
int CountPendingLimitOrdersThisEA()
{
    int c=0;
    for(int i=0;i<OrdersTotal();++i)
    {
        ulong ticket = OrderGetTicket(i);
        if(ticket==0) continue;
        if(!OrderSelect(ticket)) continue;
        
        if((string)OrderGetString(ORDER_SYMBOL) != _Symbol) continue;
        long magic = (long)OrderGetInteger(ORDER_MAGIC);
        if(magic != Magic_Main) continue;
        
        long t = (long)OrderGetInteger(ORDER_TYPE);
        if(t==ORDER_TYPE_BUY_LIMIT || t==ORDER_TYPE_SELL_LIMIT) c++;
    }
    return c;
}

// ====================== CORRECTED TryScalpEntries() FUNCTION ======================
void TryScalpEntries()
{
    if(!Use_Scalp_Mode) return;
    
    // Check if trading is enabled
    if (!Trading_Enabled && Auto_Trade) {
        // Still send signal but don't execute trade
        double stLine_ignored = 0;
        int    dirM15 = 0;
        if(!CalcSuperTrend(TF_Trade, ST_ATR_Period, ST_ATR_Mult, 1, stLine_ignored, dirM15))
        {
            return;
        }
        
        // Send signal only
        SendTG("üìà Scalp Signal Detected (Trading Disabled)");
        return;
    }
    
    if (!Trading_Enabled) return;
    
    double stLine_ignored = 0;
    int    dirM15 = 0;
    if(!CalcSuperTrend(TF_Trade, ST_ATR_Period, ST_ATR_Mult, 1, stLine_ignored, dirM15))
    {
        return;
    }
    
    if(Scalp_Only_When_No_Main && CountOpen()>0) return;
    
    if(CountOpenScalp() >= Scalp_Max_Concurrent) return;
    
    double rp = (Risk_Percent_Scalp > 0.0 ? Risk_Percent_Scalp
                 : Risk_Percent * Scalp_Risk_Mult);
    
    int htfDir = 0, htfAge = 0;
    if(Scalp_Gate_By_HTF)
    {
        if(!IsStrongBreakoutHTF(
                                TF_Scalp_Gate_HTF,
                                HTF_Breakout_Lookback,
                                Scalp_ATR_Period,
                                Scalp_Gate_ATR_Margin,
                                0,
                                HTF_Breakout_MaxAgeBars,
                                htfDir, htfAge))
        {
            return;
        }
    }
    double mom_scalp = MomentumValue(TF_Scalp, 1);
    bool momBuyOK_scalp = !Use_Momentum_Filter || (mom_scalp > 100.0 && (mom_scalp - 100.0) >= Mom_Scalp_Min_Strength);
    bool momSellOK_scalp = !Use_Momentum_Filter || (mom_scalp < 100.0 && (100.0 - mom_scalp) >= Mom_Scalp_Min_Strength);
    
    int    ag  = AlligatorState(TF_Scalp, 1);
    double ao1 = AOValue(TF_Scalp, 1);
    double ao2 = AOValue(TF_Scalp, 2);
    
    bool aoUp = !Use_AO_Filter || (ao1>0.0 && MathAbs(ao1)>=AO_Scalp_Min_Strength && ao1>=ao2);
    bool aoDn = !Use_AO_Filter || (ao1<0.0 && MathAbs(ao1)>=AO_Scalp_Min_Strength && ao1<=ao2);
    
    bool alligatorBuyOK_scalp = !Use_Alligator_Filter || (ag > 0);
    bool alligatorSellOK_scalp = !Use_Alligator_Filter || (ag < 0);
    double w_scalp = WPRValue(TF_Scalp_Gate_HTF, 1);
    // Filter 1: The -50 "Bias" filter
    bool wBuyOK_scalp  = !Use_WPR_Filter || !Use_WPR_Bias || (w_scalp > -50.0);
    bool wSellOK_scalp = !Use_WPR_Filter || !Use_WPR_Bias || (w_scalp < -50.0);
    // Filter 2: The Overbought/Oversold filter
    bool wprFilterScalpBuyOK  = !Use_WPR_Filter || !Use_OverboughtOversold_Filter || (w_scalp < WPR_Overbought_Level);
    bool wprFilterScalpSellOK = !Use_WPR_Filter || !Use_OverboughtOversold_Filter || (w_scalp > WPR_Oversold_Level);
    // --- END NEW ---
    
    // --- MODIFIED: Combine ALL filters in final conditions ---
    bool buy  = (alligatorBuyOK_scalp && aoUp && wBuyOK_scalp && wprFilterScalpBuyOK && momBuyOK_scalp);
    bool sell = (alligatorSellOK_scalp && aoDn && wSellOK_scalp && wprFilterScalpSellOK && momSellOK_scalp);
    
    if(Scalp_Gate_By_HTF)
    {
        if(htfDir>0) sell = false;
        if(htfDir<0) buy  = false;
    }
    
    if(!(buy || sell)) return;
    
    bool isTrendFlip = (dirM15 != 0 && dirM15 != prevDir_ST);
    
    if(Use_Breakout_Confirmation && isTrendFlip && !g_breakoutConfirmed)
    {
        bool isCleanBreakoutFound = false;
        if(buy)
        {
            isCleanBreakoutFound = IsCleanBreakout(POSITION_TYPE_BUY, Required_Confirmation_Candles, TF_Scalp);
        }
        else if(sell)
        {
            isCleanBreakoutFound = IsCleanBreakout(POSITION_TYPE_SELL, Required_Confirmation_Candles, TF_Scalp);
        }
        
        if(isCleanBreakoutFound)
        {
            g_breakoutConfirmed = true;
        }
        else
        {
            buy = false;
            sell = false;
        }
    }
    
    if(!(buy || sell)) return;
    
    int hATR = iATR(_Symbol, TF_Scalp, Scalp_ATR_Period);
    double atr=0.0;
    if(hATR!=INVALID_HANDLE){
        double a[]; ArraySetAsSeries(a,true);
        if(CopyBuffer(hATR,0,0,3,a)>=2) atr=a[1];
        IndicatorRelease(hATR);
    }
    if(atr<=0) return;
    
    double ask  = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
    double bid  = SymbolInfoDouble(_Symbol,SYMBOL_BID);
    double entry= buy? ask : bid;
    
    int bH,bL; double pHs,pLs;
    if(!RecentSwings(TF_Scalp, 200, bH,pHs,bL,pLs)) { pHs=iHigh(_Symbol,TF_Scalp,1); pLs=iLow(_Symbol,TF_Scalp,1); }
    
    double sl=0.0;
    if(Use_Dynamic_SL_ATR){
        if(buy){
            if(!PickSL_DynamicATR(true, entry, atr, pHs, pLs, SL_ATR_Min, SL_ATR_Max, SL_Swing_Pad_ATR, sl)) return;
        }else{
            if(!PickSL_DynamicATR(false, entry, atr, pHs, pLs, SL_ATR_Min, SL_ATR_Max, SL_Swing_Pad_ATR, sl)) return;
        }
    }else{
        sl = buy? (entry - Scalp_SL_ATR_Mult*atr)
        : (entry + Scalp_SL_ATR_Mult*atr);
    }
    
    double tp = 0.0;
    bool tpOk = false;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(PositionSelectByTicket(PositionGetTicket(i)))
        {
            long posMagic = PositionGetInteger(POSITION_MAGIC);
            if((posMagic == Magic_Main) &&
               StringFind(PositionGetString(POSITION_COMMENT), "Scalp", 0) < 0)
            {
                tp = PositionGetDouble(POSITION_TP);
                if(tp > 0)
                {
                    tpOk = true;
                    break;
                }
            }
        }
    }
    
    if(!tpOk)
    {
        double pH, pL, atrMain;
        if(GetSwingsATR(TF_Trade, 300, ST_ATR_Period, pH, pL, atrMain))
        {
            if(Use_RR_Range)
            {
                double chosenR=0, dynTP=0;
                tpOk = PickRRTarget(buy, entry, sl, atrMain, pH, pL,
                                    RR_Min, RR_Max, TP_Max_ATR_Mult, TP_Swing_Ext_ATR_Mult,
                                    chosenR, dynTP);
                if(tpOk) tp = dynTP;
            }
            if(!tpOk)
            {
                double leg = MathAbs(pH - pL);
                tp = buy ? (pH + 2.618 * leg) : (pL - 2.618 * leg);
                tpOk = (tp != 0);
            }
        }
    }
    
    if(!tpOk || tp == 0.0)
    {
        string rejectMsg = StringFormat(
                                        "‚ùå <b>SCALP %s REJECTED</b>\n\n"
                                        "üìä <b>Symbol:</b> %s\n"
                                        "‚ö° <b>Reason:</b> Failed to find TP > Min RR (%.1f)",
                                        buy ? "BUY" : "SELL",
                                        _Symbol,
                                        Scalp_RR_Min
                                        );
        SendTG(rejectMsg);
        return;
    }
    
    { double ssl=sl, stp=tp; SanitizeStops(buy?POSITION_TYPE_BUY:POSITION_TYPE_SELL, ssl, stp); sl=ssl; tp=stp; }
    if(TP_Pullback_ATR_Mult > 0 && tp > 0)
    {
        if(buy) tp = tp - (TP_Pullback_ATR_Mult * atr);
        else    tp = tp + (TP_Pullback_ATR_Mult * atr);
    }
    if( (buy && (entry - sl) <= 0) || (!buy && (sl - entry) <= 0) ) return;
    
    double jaw, teeth, lips;
    if (!GetAlligatorLines(TF_Scalp, 1, jaw, teeth, lips)) return;
    double idealEntry = lips;
    
    double zone = Scalp_Market_Entry_ATR_Zone * atr;
    bool inMarketZone = buy ? (entry <= idealEntry + zone) : (entry >= idealEntry - zone);
    
    string entryType = "";
    double entryPrice = 0.0;
    double finalSL = sl;
    double finalTP = tp;
    
    if(Scalp_Market_Entry_ATR_Zone > 0 && inMarketZone)
    {
        entryType = "Market";
        entryPrice = entry;
    }
    else
    {
        entryType = "Limit";
        entryPrice = idealEntry;
        
        finalSL = buy ? (entryPrice - MathAbs(entry - sl)) : (entryPrice + MathAbs(sl - entry));
        finalTP = buy ? (entryPrice + MathAbs(tp - entry)) : (entryPrice - MathAbs(entry - tp));
        
        if (buy && finalSL >= entryPrice) finalSL = entryPrice - 2.0 * atr;
        if (!buy && finalSL <= entryPrice) finalSL = entryPrice + 2.0 * atr;
        
        SanitizeStops(buy ? POSITION_TYPE_BUY : POSITION_TYPE_SELL, finalSL, finalTP);
    }
    
    double riskPtsForLots = buy ? (entryPrice - finalSL) / _Point : (finalSL - entryPrice) / _Point;
    if (riskPtsForLots <= MinStopPoints()) return;
    if(Use_Anti_Chasing_Filter)
    {
        // idealEntry (lips line) is the base, entryPrice is the actual entry
        double totalDist = MathAbs(finalTP - idealEntry);
        double currentDist = MathAbs(entryPrice - idealEntry);
        if (totalDist > 0)
        {
            double progressPct = (currentDist / totalDist) * 100.0;
            if (progressPct > Anti_Chasing_Filter_Percent)
            {
                SendTG(StringFormat("‚ùå SCALP %s skipped (Anti-Chasing). Progress: %.1f%%", buy ? "BUY" : "SELL", progressPct));
                return; // Abort trade
            }
        }
    }
    
    bool   useFixedLot = Scalp_Use_Fixed_Lot;
    double fixedLots   = (Fixed_Lots_Scalp > 0.0 ? Fixed_Lots_Scalp : Fixed_Lots);
    double lots = useFixedLot ? NormalizeVolume(fixedLots) : LotsByRisk(rp, riskPtsForLots);
    
    Trade.SetExpertMagicNumber(Magic_Scalp);
    sent = false;
    
    string signalType = buy ? "üìà SCALP BUY SIGNAL üìà" : "üìâ SCALP SELL SIGNAL üìâ";
    string signalMsg = StringFormat(
                                    "<b>%s</b> (%s)\n\n"
                                    "üìä <b>Symbol:</b> %s\n"
                                    "‚è∞ <b>Timeframe:</b> %s\n"
                                    "üí∞ <b>Entry Price:</b> %s\n"
                                    "‚ö° <b>Strategy:</b> Scalp\n\n"
                                    "<i>Preparing to execute trade...</i>",
                                    signalType, entryType,
                                    _Symbol,
                                    tfstr(TF_Scalp),
                                    DoubleToString(entryPrice, _Digits)
                                    );
    SendTG(signalMsg);
    
    if (Auto_Trade && Trading_Enabled)
    {
        if (entryType == "Market")
        {
            if (buy) sent = Trade.Buy(lots, _Symbol, 0, finalSL, finalTP, "V25 Scalp Buy");
            else sent = Trade.Sell(lots, _Symbol, 0, finalSL, finalTP, "V25 Scalp Sell");
        }
        else
        {
            datetime expiration = TimeCurrent() + (Scalp_StopEntry_Expiry_Bars * PeriodSeconds(TF_Scalp));
            if (buy) sent = Trade.BuyLimit(lots, entryPrice, _Symbol, finalSL, finalTP, ORDER_TIME_SPECIFIED, expiration, "V25 Scalp Buy Limit");
            else sent = Trade.SellLimit(lots, entryPrice, _Symbol, finalSL, finalTP, ORDER_TIME_SPECIFIED, expiration, "V25 Scalp Sell Limit");
        }
    }
}

// CORRECTED TryEntries FUNCTION
void TryEntries()
{
    static datetime lastEvalBar = 0;
    datetime barTime = iTime(_Symbol, TF_Trade, 0);
    if(barTime == lastEvalBar) return;
    lastEvalBar = barTime;
    
    if(lastTradeBarTime!=0 && (barTime - lastTradeBarTime) < (long)PeriodSeconds(TF_Trade)*Cooldown_Bars)
        return;
    
    if(stageCount >= Max_Entry_Stages)
    {
        return;
    }
    
    if(lastTradeBarTime == barTime) return;
    
    // Check if trading is enabled
    if (!Trading_Enabled && Auto_Trade) {
        // Still calculate and send signals but don't execute trades
        double stLineM15=0;
        int    dirM15=0;
        
        if(!CalcSuperTrend(TF_Trade, ST_ATR_Period, ST_ATR_Mult, 1, stLineM15, dirM15)) return;
        
        // Send signal only
        SendTG("üìà Main Trend Signal Detected (Trading Disabled)");
        return;
    }
    
    if (!Trading_Enabled) return;
    
    double stLineM15=0, stLineH1=0, stLineH4=0;
    int    dirM15=0, dirH1=0, dirH4=0;
    
    if(!CalcSuperTrend(TF_Trade, ST_ATR_Period, ST_ATR_Mult, 1, stLineM15, dirM15)) return;
    if(Use_H1H4_Filter)
    {
        if(!CalcSuperTrend(PERIOD_H1, ST_ATR_Period, ST_ATR_Mult, 1, stLineH1, dirH1)) return;
        if(!CalcSuperTrend(PERIOD_H4, ST_ATR_Period, ST_ATR_Mult, 1, stLineH4, dirH4)) return;
    }
    
    int    ag = AlligatorState(TF_Trade,1);
    double ao = AOValue(TF_Trade,1);
    double w  = WPRValue(TF_HTF_Breakout,1);
    double c  = iClose(_Symbol, TF_Trade, 1);
    
    bool hOK = (!Use_H1H4_Filter) || (dirH1==dirM15 && dirH4==dirM15);
    
    bool wBuyOK  = !Use_WPR_Filter || !Use_WPR_Bias || (w > -50.0);
    bool wSellOK = !Use_WPR_Filter || !Use_WPR_Bias || (w < -50.0);
    if(Use_WPR_Cross)
    {
        double wPrev = WPRValue(TF_Trade,2);
        wBuyOK  = (wPrev < -80.0 && w > -80.0);
        wSellOK = (wPrev > -20.0 && w < -20.0);
    }
    
    if(dirM15 != 0 && dirM15 != prevDir_ST)
    {
        flipBar             = iTime(_Symbol, TF_Trade, 1);
        stageCount          = 0;
        g_breakoutConfirmed = false;
    }
    prevDir_ST = dirM15;
    
    bool flipWaitOK = true;
    if(Use_ST_Flip_Retest && flipBar!=0){
        int barsSinceFlip = (int)((iTime(_Symbol,TF_Trade,1) - flipBar) / (long)PeriodSeconds(TF_Trade));
        flipWaitOK = (barsSinceFlip >= Min_Bars_After_Flip);
    }
    double mom = MomentumValue(TF_Trade, 1);
    bool momBuyOK = !Use_Momentum_Filter || (mom > 100.0 && (mom - 100.0) >= Mom_Min_Strength);
    bool momSellOK = !Use_Momentum_Filter || (mom < 100.0 && (100.0 - mom) >= Mom_Min_Strength);
    
    bool alligatorBuyOK = !Use_Alligator_Filter || (ag > 0);
    bool alligatorSellOK = !Use_Alligator_Filter || (ag < 0);
    
    bool aoBuyOK  = !Use_AO_Filter || (ao > 0.0 && MathAbs(ao) >= AO_Min_Strength);
    bool aoSellOK = !Use_AO_Filter || (ao < 0.0 && MathAbs(ao) >= AO_Min_Strength);
    bool wprFilterBuyOK  = !Use_WPR_Filter || !Use_OverboughtOversold_Filter || (w < WPR_Overbought_Level);
    bool wprFilterSellOK = !Use_WPR_Filter || !Use_OverboughtOversold_Filter || (w > WPR_Oversold_Level);
    bool buyCond  = (dirM15>0 && alligatorBuyOK && aoBuyOK && wBuyOK && hOK && c>stLineM15 && wprFilterBuyOK && momBuyOK);
    bool sellCond = (dirM15<0 && alligatorSellOK && aoSellOK && wSellOK && hOK && c<stLineM15 && wprFilterSellOK && momSellOK);
    
    bool isFreshFlip = (flipBar == iTime(_Symbol, TF_Trade, 1));
    
    if(Use_Breakout_Confirmation && isFreshFlip && !g_breakoutConfirmed)
    {
        bool isCleanBreakoutFound = false;
        if(buyCond)
        {
            isCleanBreakoutFound = IsCleanBreakout(POSITION_TYPE_BUY, Required_Confirmation_Candles, TF_Trade);
        }
        else if(sellCond)
        {
            isCleanBreakoutFound = IsCleanBreakout(POSITION_TYPE_SELL, Required_Confirmation_Candles, TF_Trade);
        }
        
        if(isCleanBreakoutFound)
        {
            g_breakoutConfirmed = true;
            if(dirM15 > 0) sellCond = false;
            if(dirM15 < 0) buyCond = false;
        }
        else
        {
            if(buyCond) buyCond = false;
            if(sellCond) sellCond = false;
        }
    }
    
    if(Use_HTF_Breakout_Filter)
    {
        ENUM_TIMEFRAMES tfHTF = TF_HTF_Breakout;
        
        int bH_htf, bL_htf; double pH_htf, pL_htf;
        if(!RecentSwings(tfHTF, 600, bH_htf, pH_htf, bL_htf, pL_htf)) return;
        
        double atrHTF = 0.0;
        int hATR_htf = iATR(_Symbol, tfHTF, ST_ATR_Period);
        if(hATR_htf!=INVALID_HANDLE)
        {
            double ahtf[]; ArraySetAsSeries(ahtf,true);
            if(CopyBuffer(hATR_htf,0,0,3,ahtf)>=2) atrHTF = ahtf[1];
            IndicatorRelease(hATR_htf);
        }
        if(atrHTF<=0.0) return;
        
        double cHTF = iClose(_Symbol, tfHTF, 1);
        double mHTF = Breakout_ATR_Margin * atrHTF;
        
        bool htfBuyOK  = (cHTF >= (pH_htf + mHTF));
        bool htfSellOK = (cHTF <= (pL_htf - mHTF));
        
        if(htfBuyOK && !htfSellOK)
        {
            sellCond = false;
        }
        else if(htfSellOK && !htfBuyOK)
        {
            buyCond = false;
        }
        else
        {
            buyCond = false;
            sellCond = false;
        }
    }
    
    if(One_Trade_At_A_Time && CountOpenMain()>0)
    {
        string rejectMsg = StringFormat(
                                        "‚ùå <b>TRADE REJECTED - Max Positions</b>\n\n"
                                        "‚è∞ <b>Timeframe:</b> %s\n"
                                        "üìä <b>Symbol:</b> %s\n"
                                        "üìà <b>Current Positions:</b> %d\n"
                                        "üî¢ <b>Max Allowed:</b> 1\n"
                                        "‚ö° <b>Signal:</b> Main Trend\n\n",
                                        _Symbol,
                                        CountOpen(),
                                        buyCond ? "BUY" : (sellCond ? "SELL" : "N/A")
                                        );
        SendTG(rejectMsg);
        return;
    }
    
    if(buyCond || sellCond)
    {
        int bH; double pH; int bL; double pL;
        if(!RecentSwings(TF_Trade, 300, bH,pH,bL,pL)) return;
        
        int hATR = iATR(_Symbol, TF_Trade, ST_ATR_Period);
        double atr=0.0;
        if(hATR!=INVALID_HANDLE)
        {
            double a[]; ArraySetAsSeries(a,true);
            if(CopyBuffer(hATR,0,0,3,a)>=2) atr = a[1];
            IndicatorRelease(hATR);
        }
        if(atr<=0.0) return;
        
        double sl=0, tp=0;
        double ask=SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        double bid=SymbolInfoDouble(_Symbol, SYMBOL_BID);
        
        if(buyCond)
        {
            double entry = ask;
            
            if(Use_Dynamic_SL_ATR){
                if(!PickSL_DynamicATR(true, entry, atr, pH, pL, SL_ATR_Min, SL_ATR_Max, SL_Swing_Pad_ATR, sl))
                    return;
            }else{
                sl = pL - ATR_SL_Buffer_Mult * atr;
            }
            
            bool tpOk=false;
            if(Use_RR_Range){
                double chosenR=0, dynTP=0;
                tpOk = PickRRTarget(true, entry, sl, atr, pH, pL,
                                    RR_Min, RR_Max, TP_Max_ATR_Mult, TP_Swing_Ext_ATR_Mult,
                                    chosenR, dynTP);
                if(tpOk) tp = dynTP;
            }
            if(!tpOk){
                double leg = MathAbs(pH - pL);
                tp = pH + 2.618 * leg;
            }
            
            bool allowStage=false;
            if(!Use_ST_Flip_Retest){
                allowStage=true;
            }else{
                double tol = Retest_ATR_Tolerance * atr;
                bool retestTouch = (iLow(_Symbol, TF_Trade, 1) <= stLineM15 + tol);
                bool confirmAway = (c >= stLineM15 + Confirm_Close_Dist_ATR * atr);
                bool confirmOk   = (ag>0 && aoBuyOK && wBuyOK && hOK && confirmAway && flipWaitOK);
                
                if(stageCount==0) allowStage = (retestTouch && confirmOk);
                else{
                    ulong tk; double e0, sl0; bool nearSL=false;
                    if(GetLatestOpenPos(+1, true, tk, e0, sl0))
                        nearSL = ReachedRatioToSL(+1, e0, sl0, AddEntry_Trigger_Ratio);
                    allowStage = (retestTouch && confirmOk && nearSL);
                }
            }
            if(!allowStage || stageCount>=Max_Entry_Stages) return;
            
            if(Use_ST_as_Stop){
                double stPad = ST_Stop_Pad_Mult * atr;
                sl = MathMin(sl, stLineM15 - stPad);
                double minPtsBuy = MathMax((int)Min_SL_Points, (int)MathRound((Min_SL_ATR_Mult*atr)/_Point));
                if( ((entry - sl)/_Point) < minPtsBuy ) return;
            }
            
            { double ssl=sl, stp=tp; SanitizeStops(POSITION_TYPE_BUY, ssl, stp); sl=ssl; tp=stp; }
            if(TP_Pullback_ATR_Mult > 0 && tp > 0)
            {
                tp = tp - (TP_Pullback_ATR_Mult * atr);
            }
            if((entry - sl) <= 0) return;
            
            if(Require_Retrace_Or_Breakout)
            {
                double tolX = Retest_ATR_Tolerance * atr;
                bool retraceOK = (iLow(_Symbol, TF_Trade, 1) <= stLineM15 + tolX);
                bool breakoutOK = (c >= (pH + Breakout_ATR_Margin * atr));
                if(!(retraceOK || breakoutOK)) return;
                if(Use_Anti_Chasing_Filter)
                {
                    // Check progress from SuperTrend line (stLineM15) to TP
                    double totalDist = MathAbs(tp - stLineM15);
                    double currentDist = MathAbs(entry - stLineM15);
                    if (totalDist > 0)
                    {
                        double progressPct = (currentDist / totalDist) * 100.0;
                        if (progressPct > Anti_Chasing_Filter_Percent)
                        {
                            SendTG(StringFormat("‚ùå BUY trade skipped (Anti-Chasing). Progress: %.1f%%", progressPct));
                            return; // Abort trade
                        }
                    }
                }
            }
            
            SendTG(StringFormat("üìà <b>BUY Setup</b> %s %s\nST:%s  Alligator:bull  AO:%.2f  WPR:%.1f\nEntry: %.2f  SL: %.2f  TP: %.2f",
                                _Symbol, tfstr(TF_Trade), "UP", ao, w, entry, sl, tp));
            
            if(Auto_Trade && Trading_Enabled)
            {
                Trade.SetExpertMagicNumber(Magic_Main);
                sent=false;
                double msgEntryPrice = entry;
                
                if(Use_Pending_Stop_Entries)
                {
                    if(CountPendingThisEA()>0) return;
                    double hi1 = iHigh(_Symbol, TF_Trade, 1);
                    double stopPrice = hi1 + StopEntry_Offset_ATR * atr;
                    double riskPtsForLots = (stopPrice - sl) / _Point;
                    double lots = LotsByRisk(Risk_Percent, riskPtsForLots);
                    msgEntryPrice = stopPrice;
                    
                    datetime expiration_buy = TimeCurrent();
                    expiration_buy += (StopEntry_Expiry_Bars * PeriodSeconds(TF_Trade));
                    
                    sent = Trade.BuyStop(lots, stopPrice, _Symbol, sl, tp,
                                         ORDER_TIME_SPECIFIED, expiration_buy, "V25 BuyStop");
                    
                    string buySignalMsg = StringFormat(
                                                       "üìà <b>BUY SIGNAL DETECTED</b> üìà\n\n"
                                                       "üìä <b>Symbol:</b> %s\n"
                                                       "‚è∞ <b>Timeframe:</b> %s\n"
                                                       "üí∞ <b>Current Price:</b> %s\n"
                                                       "üìà <b>SuperTrend:</b> %s\n"
                                                       "‚ö° <b>Strategy:</b> Main Trend\n\n"
                                                       "<i>Preparing to execute trade...</i>",
                                                       _Symbol,
                                                       tfstr(TF_Trade),
                                                       DoubleToString(entry, _Digits),
                                                       DoubleToString(stLineM15, _Digits)
                                                       );
                    SendTG(buySignalMsg);
                }
                else
                {
                    double lots = LotsByRisk(Risk_Percent, (entry - sl)/_Point);
                    sent = Trade.Buy(lots, _Symbol, entry, sl, tp, "V25 Buy");
                }
                
                if(sent)
                {
                    SendTG(StringFormat("[üìà BUY placed\nEntry %.2f\nSL %.2f\nTP %.2f]", msgEntryPrice, sl, tp));
                    lastTradeBarTime = iTime(_Symbol, TF_Trade, 0);
                    stageCount = MathMin(stageCount+1, Max_Entry_Stages);
                    lastStageBar = iTime(_Symbol, TF_Trade, 0);
                    if(Adjust_All_To_Latest) ApplySLTPToAllOpen(+1, sl, tp);
                }
                else
                {
                    SendTG(StringFormat("‚ùå BUY send failed: ret=%d", Trade.ResultRetcode()));
                }
            }
        }
        else if(sellCond)
        {
            double entry = bid;
            
            if(Use_Dynamic_SL_ATR){
                if(!PickSL_DynamicATR(false, entry, atr, pH, pL, SL_ATR_Min, SL_ATR_Max, SL_Swing_Pad_ATR, sl))
                    return;
            }else{
                sl = pH + ATR_SL_Buffer_Mult * atr;
            }
            
            bool tpOk=false;
            if(Use_RR_Range){
                double chosenR=0, dynTP=0;
                tpOk = PickRRTarget(false, entry, sl, atr, pH, pL,
                                    RR_Min, RR_Max, TP_Max_ATR_Mult, TP_Swing_Ext_ATR_Mult,
                                    chosenR, dynTP);
                if(tpOk) tp = dynTP;
            }
            if(!tpOk){
                double leg = MathAbs(pH - pL);
                tp = pL - 2.618 * leg;
            }
            
            bool allowStage=false;
            if(!Use_ST_Flip_Retest){
                allowStage=true;
            }else{
                double tol = Retest_ATR_Tolerance * atr;
                bool retestTouch = (iHigh(_Symbol, TF_Trade, 1) >= stLineM15 - tol);
                bool confirmAway = (c <= stLineM15 - Confirm_Close_Dist_ATR * atr);
                bool confirmOk   = (ag<0 && aoSellOK && wSellOK && hOK && confirmAway && flipWaitOK);
                
                if(stageCount==0) allowStage = (retestTouch && confirmOk);
                else{
                    ulong tk; double e0, sl0; bool nearSL=false;
                    if(GetLatestOpenPos(-1, true, tk, e0, sl0))
                        nearSL = ReachedRatioToSL(-1, e0, sl0, AddEntry_Trigger_Ratio);
                    allowStage = (retestTouch && confirmOk && nearSL);
                }
            }
            if(!allowStage || stageCount>=Max_Entry_Stages) return;
            
            if(Use_ST_as_Stop){
                double stPad = ST_Stop_Pad_Mult * atr;
                sl = MathMax(sl, stLineM15 + stPad);
            }
            {
                double minPtsSell = MathMax((int)Min_SL_Points, (int)MathRound((Min_SL_ATR_Mult*atr)/_Point));
                if( ((sl - entry)/_Point) < minPtsSell ) return;
            }
            
            { double ssl=sl, stp=tp; SanitizeStops(POSITION_TYPE_SELL, ssl, stp); sl=ssl; tp=stp; }
            if(TP_Pullback_ATR_Mult > 0 && tp > 0)
            {
                tp = tp + (TP_Pullback_ATR_Mult * atr);
            }
            if((sl - entry) <= 0) return;
            
            if(Require_Retrace_Or_Breakout)
            {
                double tolX = Retest_ATR_Tolerance * atr;
                bool retraceOK = (iHigh(_Symbol, TF_Trade, 1) >= stLineM15 - tolX);
                bool breakoutOK = (c <= (pL - Breakout_ATR_Margin * atr));
                if(!(retraceOK || breakoutOK)) return;
                if(Use_Anti_Chasing_Filter)
                {
                    // Check progress from SuperTrend line (stLineM15) to TP
                    double totalDist = MathAbs(tp - stLineM15);
                    double currentDist = MathAbs(entry - stLineM15);
                    if (totalDist > 0)
                    {
                        double progressPct = (currentDist / totalDist) * 100.0;
                        if (progressPct > Anti_Chasing_Filter_Percent)
                        {
                            SendTG(StringFormat("‚ùå SELL trade skipped (Anti-Chasing). Progress: %.1f%%", progressPct));
                            return; // Abort trade
                        }
                    }
                }
            }
            
            SendTG(StringFormat("üìâ <b>SELL Setup</b> %s %s\nST:%s  Alligator:bear  AO:%.2f  WPR:%.1f\nEntry: %.2f  SL: %.2f  TP: %.2f",
                                _Symbol, tfstr(TF_Trade), "DOWN", ao, w, entry, sl, tp));
            
            if(Auto_Trade && Trading_Enabled)
            {
                Trade.SetExpertMagicNumber(Magic_Main);
                sent=false;
                double msgEntryPrice = entry;
                
                if(Use_Pending_Stop_Entries)
                {
                    if(CountPendingThisEA()>0) return;
                    double lo1 = iLow(_Symbol, TF_Trade, 1);
                    double stopPrice = lo1 - StopEntry_Offset_ATR * atr;
                    double riskPtsForLots = (sl - stopPrice) / _Point;
                    double lots = LotsByRisk(Risk_Percent, riskPtsForLots);
                    msgEntryPrice = stopPrice;
                    
                    datetime expiration_sell = TimeCurrent();
                    expiration_sell += (StopEntry_Expiry_Bars * PeriodSeconds(TF_Trade));
                    
                    sent = Trade.SellStop(lots, stopPrice, _Symbol, sl, tp,
                                          ORDER_TIME_SPECIFIED, expiration_sell, "V25 SellStop");
                    
                    string sellSignalMsg = StringFormat(
                                                        "üìâ <b>SELL SIGNAL DETECTED</b> üìâ\n\n"
                                                        "üìä <b>Symbol:</b> %s\n"
                                                        "‚è∞ <b>Timeframe:</b> %s\n"
                                                        "üí∞ <b>Current Price:</b> %s\n"
                                                        "üìâ <b>SuperTrend:</b> %s\n"
                                                        "‚ö° <b>Strategy:</b> Main Trend\n\n"
                                                        "<i>Preparing to execute trade...</i>",
                                                        _Symbol,
                                                        tfstr(TF_Trade),
                                                        DoubleToString(entry, _Digits),
                                                        DoubleToString(stLineM15, _Digits)
                                                        );
                    SendTG(sellSignalMsg);
                }
                else
                {
                    double lots = LotsByRisk(Risk_Percent, (sl - entry)/_Point);
                    sent = Trade.Sell(lots, _Symbol, entry, sl, tp, "V25 Sell");
                }
                
                if(sent)
                {
                    SendTG(StringFormat("[üìâ SELL placed\nEntry %.2f\nSL %.2f\nTP %.2f]", msgEntryPrice, sl, tp));
                    lastTradeBarTime = iTime(_Symbol, TF_Trade, 0);
                    stageCount = MathMin(stageCount+1, Max_Entry_Stages);
                    lastStageBar = iTime(_Symbol, TF_Trade, 0);
                    if(Adjust_All_To_Latest) ApplySLTPToAllOpen(-1, sl, tp);
                }
                else
                {
                    SendTG(StringFormat("‚ùå SELL send failed: ret=%d", Trade.ResultRetcode()));
                }
            }
        }
    }
}

// CORRECTED ManageOpenPositions FUNCTION
void ManageOpenPositions()
{
    double main_st_line; int main_st_dir;
    if (!CalcSuperTrend(TF_Trade, ST_ATR_Period, ST_ATR_Mult, 1, main_st_line, main_st_dir)) return;
    
    double scalp_st_line; int scalp_st_dir;
    if (Use_Scalp_Mode && !CalcSuperTrend(TF_Scalp, ST_ATR_Period, ST_ATR_Mult, 1, scalp_st_line, scalp_st_dir)) return;
    
    for(int p = PositionsTotal() - 1; p >= 0; p--)
    {
        ulong ticket = PositionGetTicket(p);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string sym = (string)PositionGetString(POSITION_SYMBOL);
        if(sym != _Symbol) continue;
        
        long magic = PositionGetInteger(POSITION_MAGIC);
        bool isEA      = (magic==Magic_Main || magic==Magic_Scalp);
        bool isManual  = (magic==0);
        
        if(!(isEA || (ApplyToManualTrades && isManual))) continue;
        
        long   type  = PositionGetInteger(POSITION_TYPE);
        double entry = PositionGetDouble(POSITION_PRICE_OPEN);
        double sl    = PositionGetDouble(POSITION_SL);
        double tp    = PositionGetDouble(POSITION_TP);
        double cur = (type==POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        string pcomment = (string)PositionGetString(POSITION_COMMENT);
        bool   isScalp  = (magic==Magic_Scalp);
        int requiredDir = (type == POSITION_TYPE_BUY) ? +1 : -1;
        
        if (prevDir_ST != 0 && main_st_dir != prevDir_ST && requiredDir != main_st_dir)
        {
            if (Trade.PositionClose(ticket))
            {
                double volume = PositionGetDouble(POSITION_VOLUME);
                double contractSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
                double swap = PositionGetDouble(POSITION_SWAP);
                double commission = 0.0;
                
                double grossProfit = 0;
                if (type == POSITION_TYPE_BUY) {
                    grossProfit = (cur - entry) * volume * contractSize;
                } else {
                    grossProfit = (entry - cur) * volume * contractSize;
                }
                double netProfit = grossProfit + swap + commission;
                string profitEmoji = (netProfit >= 0) ? "‚úÖ" : "‚ùå";
                string profitSign = (netProfit >= 0) ? "+" : "";
                string typeStr = (type == POSITION_TYPE_BUY) ? "BUY" : "SELL";
                
                string flipMsg = StringFormat(
                                              "üîÑ <b>POSITION CLOSED (Trend Flip)</b> üîÑ\n\n"
                                              "üìä <b>Symbol:</b> %s\n"
                                              "üî¢ <b>Ticket:</b> %I64u\n"
                                              "üìà <b>Type:</b> %s\n"
                                              "üí¨ <b>Comment:</b> %s\n\n"
                                              "‚ñ∂Ô∏è <b>Entry:</b> %s\n"
                                              "‚èπÔ∏è <b>Exit:</b> %s\n"
                                              "üí∞ <b>Profit/Loss:</b> %s%s%.2f\n\n"
                                              "‚ö° <b>Reason:</b> MAIN TREND flipped on %s.",
                                              _Symbol,
                                              ticket,
                                              typeStr,
                                              pcomment,
                                              DoubleToString(entry, _Digits),
                                              DoubleToString(cur, _Digits),
                                              profitEmoji, profitSign, netProfit,
                                              tfstr(TF_Trade)
                                              );
                SendTG(flipMsg);
            }
            continue;
        }
        
        if (isScalp && prevDir_ST != 0 && scalp_st_dir != requiredDir)
        {
            if (Trade.PositionClose(ticket))
            {
                double volume = PositionGetDouble(POSITION_VOLUME);
                double contractSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
                double swap = PositionGetDouble(POSITION_SWAP);
                double commission = 0.0;
                
                double grossProfit = 0;
                if (type == POSITION_TYPE_BUY) {
                    grossProfit = (cur - entry) * volume * contractSize;
                } else {
                    grossProfit = (entry - cur) * volume * contractSize;
                }
                double netProfit = grossProfit + swap + commission;
                string profitEmoji = (netProfit >= 0) ? "‚úÖ" : "‚ùå";
                string profitSign = (netProfit >= 0) ? "+" : "";
                string typeStr = (type == POSITION_TYPE_BUY) ? "BUY" : "SELL";
                
                string scalpFlipMsg = StringFormat(
                                                   "üîÑ <b>SCALP CLOSED (Trend Flip)</b> üîÑ\n\n"
                                                   "üìä <b>Symbol:</b> %s\n"
                                                   "üî¢ <b>Ticket:</b> %I64u\n"
                                                   "üìà <b>Type:</b> %s\n"
                                                   "üí¨ <b>Comment:</b> %s\n\n"
                                                   "‚ñ∂Ô∏è <b>Entry:</b> %s\n"
                                                   "‚èπÔ∏è <b>Exit:</b> %s\n"
                                                   "üí∞ <b>Profit/Loss:</b> %s%s%.2f\n\n"
                                                   "‚ö° <b>Reason:</b> SCALP TREND flipped on %s.",
                                                   _Symbol,
                                                   ticket,
                                                   typeStr,
                                                   pcomment,
                                                   DoubleToString(entry, _Digits),
                                                   DoubleToString(cur, _Digits),
                                                   profitEmoji, profitSign, netProfit,
                                                   tfstr(TF_Scalp)
                                                   );
                SendTG(scalpFlipMsg);
            }
            continue;
        }
        
        if(Protect_Scalp_SLTP && isScalp) continue;
        
        if(Use_Momentum_Exit_Filter && isEA)
        {
            double totalDistToTP = (type == POSITION_TYPE_BUY) ? (tp - entry) : (entry - tp);
            double currentProgress = (type == POSITION_TYPE_BUY) ? (cur - entry) : (entry - cur);
            double progressPercent = 0.0;
            
            if (totalDistToTP > 0)
            {
                progressPercent = (currentProgress / totalDistToTP) * 100.0;
            }
            
            if (progressPercent >= Momentum_Exit_Min_TP_Percent)
            {
                ENUM_TIMEFRAMES divergenceTF = isScalp ? TF_Scalp : TF_Trade;
                
                if(CheckMomentumDivergence(type, Divergence_Lookback_Bars, divergenceTF))
                {
                    double potentialProfit = 0;
                    double swap = PositionGetDouble(POSITION_SWAP);
                    double fee = 0;
                    if (type == POSITION_TYPE_BUY) {
                        potentialProfit = (cur - entry) * PositionGetDouble(POSITION_VOLUME) * SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
                    } else {
                        potentialProfit = (entry - cur) * PositionGetDouble(POSITION_VOLUME) * SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
                    }
                    double potentialNet = potentialProfit + swap + fee;
                    string profitEmoji = (potentialNet >= 0) ? "‚úÖ" : "‚ùå";
                    string profitSign  = (potentialNet >= 0) ? "+" : "";
                    
                    if(Trade.PositionClose(ticket))
                    {
                        SendTG(StringFormat("</b>%s %s closed:</b>\n"
                                            "</b>MOMENTUM DIVERGENCE</b>\n"
                                            "<b>Detected on</b>: %s.\n"
                                            "<b>üí∞ Profit/Loss:</b> %s%.2f"
                                            "<b>(Exit: %.2f)</b>",
                                            profitEmoji, pcomment,
                                            tfstr(divergenceTF),
                                            profitSign, potentialNet, cur));
                    }
                    continue;
                }
            }
        }
        
        if(BE_Activation_TP_Percent > 0.0 && tp > 0.0 && sl > 0.0)
        {
            const double BE_Buffer = BE_Buffer_Points * _Point;
            
            double totalDistToTP = (type == POSITION_TYPE_BUY) ?
            (tp - entry) : (entry - tp);
            double currentProgress = (type == POSITION_TYPE_BUY) ?
            (cur - entry) : (entry - cur);
            
            if(totalDistToTP > _Point && currentProgress > 0)
            {
                double requiredProgress = totalDistToTP * (BE_Activation_TP_Percent / 100.0);
                
                if (currentProgress >= requiredProgress)
                {
                    double profitToLockIn = totalDistToTP * (BE_Profit_Percent / 100.0);
                    
                    if (profitToLockIn <= (100.0 * _Point))
                    {
                        profitToLockIn = 100.0 * _Point;
                    }
                    
                    double targetBE = (type == POSITION_TYPE_BUY) ? (entry + profitToLockIn) : (entry - profitToLockIn);
                    bool needsMove = (type == POSITION_TYPE_BUY && sl < targetBE) || (type == POSITION_TYPE_SELL && sl > targetBE);
                    if(needsMove)
                    {
                        double modSL = targetBE, modTP = tp;
                        SanitizeStops(type, modSL, modTP);
                        
                        if(modSL > 0 && MathAbs(modSL - sl) >= 0.5 * _Point)
                        {
                            if(Trade.PositionModify(_Symbol, modSL, modTP))
                            {
                                g_trailingActivated = true;
                                double progressPercent = (currentProgress / totalDistToTP) * 100.0;
                                string beMsg = StringFormat(
                                                            "üí∞ <b>BREAKEVEN ACTIVATED</b>\n\n"
                                                            "üìä <b>Symbol:</b> %s\n"
                                                            "üìà <b>Type:</b> %s\n"
                                                            "üõë <b>New SL:</b> %s\n"
                                                            "‚ö° <b>Progress:</b> %.1f%% to TP",
                                                            _Symbol,
                                                            (type == POSITION_TYPE_BUY) ? "BUY" : "SELL",
                                                            DoubleToString(modSL, _Digits),
                                                            progressPercent
                                                            );
                                SendTG(beMsg);
                            }
                            else
                            {
                                PrintFormat("DEBUG: BE Modify FAILED. Retcode: %d, Comment: %s", Trade.ResultRetcode(), Trade.ResultComment());
                            }
                        }
                    }
                }
            }
        }
        
        if(!isScalp || !Protect_Scalp_SLTP)
        {
            CheckPartialClose(ticket, type, entry, sl, tp,
                              PositionGetDouble(POSITION_VOLUME), pcomment);
        }
        
        if (Use_Dynamic_TP_Tighten)
        {
            double newTP = 0.0;
            double st_line_current = 0.0;
            int    st_dir_current = 0;
            
            if(!CalcSuperTrend(signalTF, ST_ATR_Period, ST_ATR_Mult, 0, st_line_current, st_dir_current))
            {
                continue;
            }
            
            if (type == POSITION_TYPE_BUY)
            {
                if (st_dir_current > 0 && st_line_current > entry && st_line_current < tp)
                {
                    newTP = st_line_current;
                }
            }
            else
            {
                if (st_dir_current < 0 && st_line_current < entry && st_line_current > tp)
                {
                    newTP = st_line_current;
                }
            }
            
            if (newTP == 0.0)
            {
                continue;
            }
            
            double modSL = sl;
            SanitizeStops(type, modSL, newTP);
            
            if (newTP > 0 && MathAbs(newTP - tp) >= 0.5 * _Point)
            {
                if (Trade.PositionModify(ticket, modSL, newTP))
                {
                    g_trailingActivated = true;
                    
                    SendTG(StringFormat("‚ö†Ô∏è <b>TP TIGHTENED</b> (Market Weakness)\n\n"
                                        "üìä <b>Symbol:</b> %s\n"
                                        "üî¢ <b>Ticket:</b> %I64u\n"
                                        "üéØ <b>Old TP:</b> %s\n"
                                        "üéØ <b>New TP:</b> %s (Adjusted to ST Line)\n"
                                        "‚ö° <b>Reason:</b> Weakness Score = %d/4",
                                        _Symbol, ticket,
                                        DoubleToString(tp, _Digits),
                                        DoubleToString(newTP, _Digits),
                                        weaknessScore
                                        ));
                }
            }
        }
        
        if(Use_HalfStep_Trailing && ApplyToManualTrades && isManual && tp>0.0 && sl>0.0)
        {
            static datetime lastHalfBarManual = 0;
            datetime curBar = iTime(_Symbol, TF_Trade, 0);
            bool canUpdate = (!HalfTrail_NewBar_Only || curBar!=lastHalfBarManual);
            
            if(canUpdate)
            {
                double targetPts   = (type==POSITION_TYPE_BUY) ? (tp - entry)/_Point
                : (entry - tp)/_Point;
                double progressPts = (type==POSITION_TYPE_BUY) ? (cur - entry)/_Point
                : (entry - cur)/_Point;
                
                if(progressPts > 0)
                {
                    double ratio   = MathMin(1.0, progressPts/targetPts);
                    double desired = 0.0;
                    
                    if(type==POSITION_TYPE_BUY)
                        desired = entry + 0.5 * ratio * (tp - entry);
                    else
                        desired = entry - 0.5 * ratio * (entry - tp);
                    
                    double modSL = sl, modTP = tp;
                    if(type==POSITION_TYPE_BUY && desired>sl)  modSL = desired;
                    if(type==POSITION_TYPE_SELL && desired<sl) modSL = desired;
                    
                    SanitizeStops(type, modSL, modTP);
                    
                    if(modSL>0 && MathAbs(modSL - sl) >= 0.5*_Point)
                    {
                        if(Trade.PositionModify(_Symbol, modSL, modTP))
                        {
                            g_trailingActivated = true;
                        }
                    }
                }
                
                lastHalfBarManual = curBar;
            }
            
            continue;
        }
        
        if(Use_HalfStep_Trailing)
        {
            static datetime lastHalfBar = 0;
            datetime hb = iTime(_Symbol, TF_Trade, 0);
            bool allowNow = (!HalfTrail_NewBar_Only || hb != lastHalfBar);
            if(allowNow) lastHalfBar = hb;
            
            if(allowNow)
            {
                double D = (type==POSITION_TYPE_BUY) ? (tp - entry) : (entry - tp);
                if(tp>0 && D>0.0)
                {
                    double progress = (type==POSITION_TYPE_BUY)
                    ? (cur - entry) / D
                    : (entry - cur) / D;
                    
                    if(progress <= 0.0) continue;
                    
                    if(progress > 1.0) progress = 1.0;
                    
                    double targetSL = (type==POSITION_TYPE_BUY)
                    ? (entry + 0.5 * progress * D)
                    : (entry - 0.5 * progress * D);
                    
                    double newSL = (type==POSITION_TYPE_BUY) ? MathMax(sl, targetSL)
                    : MathMin(sl, targetSL);
                    
                    double modSL=newSL, modTP=tp;
                    SanitizeStops(type, modSL, modTP);
                    
                    if(modSL>0 && MathAbs(modSL - sl) >= 0.5*_Point)
                    {
                        if(Trade.PositionModify(_Symbol, modSL, modTP))
                        {
                            g_trailingActivated = true;
                        }
                    }
                }
            }
            
            continue;
        }
        
        if(Use_ATR_Trailing && (BE_Activation_TP_Percent <= 0.0 || g_trailingActivated))
        {
            int hATR = iATR(_Symbol, TF_Trade, ATR_Period_Trail);
            if(hATR!=INVALID_HANDLE)
            {
                double a[]; ArraySetAsSeries(a,true);
                if(CopyBuffer(hATR,0,0,3,a)>=2)
                {
                    double atr = a[1];
                    if(type==POSITION_TYPE_BUY)
                    {
                        double trail = cur - ATR_Trail_Mult * atr;
                        if(trail>sl)
                        {
                            double modSL=trail, modTP=tp;
                            SanitizeStops(type, modSL, modTP);
                            if(modSL>0 && MathAbs(modSL-sl) >= 0.5*_Point)
                            {
                                if(Trade.PositionModify(_Symbol, modSL, modTP))
                                {
                                    g_trailingActivated = true;
                                }
                            }
                        }
                    }
                    else
                    {
                        double trail = cur + ATR_Trail_Mult * atr;
                        
                        if(trail < sl)
                        {
                            double modSL=trail, modTP=tp;
                            SanitizeStops(type, modSL, modTP);
                            if(modSL>0 && MathAbs(modSL-sl) >= 0.5*_Point)
                            {
                                if(Trade.PositionModify(_Symbol, modSL, modTP))
                                {
                                    g_trailingActivated = true;
                                }
                            }
                        }
                    }
                }
                IndicatorRelease(hATR);
            }
        }
    }
}

//============================== Events ==============================
// REPLACEMENT FOR OnInit() FUNCTION
int OnInit()
{
    g_eaStartTime = TimeCurrent();
    Trading_Enabled = Inp_Trading_Enabled;
    string testMsg = "üîî EA Connection Test\nTesting Telegram notifications...";
    SendTG(testMsg);
    
    string mainStrategyStatus = "ENABLED";
    string scalpStrategyStatus = Use_Scalp_Mode ? "ENABLED" : "DISABLED";
    string maxPos;
    if(One_Trade_At_A_Time) maxPos = "1";
    else maxPos = (string)Max_Entry_Stages;
    
    string activationMsg = StringFormat(
                                        "‚úÖ <b>Nodezilla101 EA Bot ACTIVATED</b>\n\n"
                                        "üìä <b>Symbol:</b> %s\n"
                                        "‚è∞ <b>Timeframe:</b> %s\n"
                                        "‚ö° <b>Main Strategy:</b> %s\n"
                                        "üìà <b>Scalp Strategy:</b> %s\n"
                                        "üìà <b>Trade TF:</b> %s\n"
                                        "üìâ <b>Scalp TF:</b> %s\n"
                                        "üî¢ <b>Max Positions:</b> %s\n\n"
                                        "<i>Monitoring for trading opportunities...</i>",
                                        _Symbol,
                                        tfstr(_Period),
                                        mainStrategyStatus,
                                        scalpStrategyStatus,
                                        tfstr(TF_Trade),
                                        tfstr(TF_Scalp),
                                        maxPos
                                        );
    SendTG(activationMsg);
    
    EventSetTimer(60);
    return(INIT_SUCCEEDED);
}

// HELPER FUNCTION TO GET DEINIT REASON
string GetDeinitReason(int reason)
{
    switch(reason)
    {
        case REASON_REMOVE:         return "EA removed by user";
        case REASON_CHARTCHANGE:    return "Chart symbol or period changed";
        case REASON_CHARTCLOSE:     return "Chart was closed";
        case REASON_PARAMETERS:     return "Input parameters changed";
        case REASON_ACCOUNT:        return "Account changed";
        case REASON_TEMPLATE:       return "New template applied";
        case REASON_RECOMPILE:      return "EA was recompiled";
        default:                    return "Unknown reason";
    }
}

//+------------------------------------------------------------------+
//| OnTick - CORRECTED VERSION                                       |
//+------------------------------------------------------------------+
void OnTick()
{
    if(Use_Volatility_CircuitBreaker)
    {
        static datetime lastBreakerTripTime = 0;
        if(TimeCurrent() - lastBreakerTripTime < 60)
        {
            return;
        }
        
        double high0 = iHigh(_Symbol, TF_Trade, 0);
        double low0  = iLow(_Symbol, TF_Trade, 0);
        double candleSize = high0 - low0;
        
        double atr = 0;
        int hATR = iATR(_Symbol, TF_Trade, ST_ATR_Period);
        if(hATR != INVALID_HANDLE)
        {
            double a[];
            if(CopyBuffer(hATR, 0, 1, 1, a) > 0) atr = a[0];
            IndicatorRelease(hATR);
        }
        
        if(atr > 0 && candleSize > (atr * CircuitBreaker_ATR_Mult))
        {
            if(PositionsTotal() > 0)
            {
                EmergencyCloseAllPositions("Extreme candle volatility detected.");
                lastBreakerTripTime = TimeCurrent();
                return;
            }
        }
    }
    
// 2. Manage Existing Trades & Orders
    ManageRetraceMarketEntry();
    ManagePendingOrders();
    ManageRetraceLimitOrders();
    TouchUpManualInitial();
    ManageOpenPositions();
    CleanupPartialClosedTickets();

    static datetime lastMainBarTime = 0;
    datetime currentMainBarTime = iTime(_Symbol, TF_Trade, 0);
    
    // --- STRATEGY EXECUTION LOGIC ---
    if(currentMainBarTime != lastMainBarTime)
    {
        lastMainBarTime = currentMainBarTime;

        // A. TIME FILTER CHECK
        // We check this FIRST. If it's not trading hours, we stop everything.
        if(Use_Time_Filter && !IsTradeTime())
        {
            Comment("üí§ Trading Paused: Outside Schedule");
            return;
        }

        // B. REGIME DETECTION
        // We re-run the math locally just for the dashboard display so you can SEE it
        
        // 1. Check H4 ADX
        double debug_ADX = 0;
        {
            int h = iADX(_Symbol, PERIOD_H4, 14);
            double b[]; ArraySetAsSeries(b,true);
            CopyBuffer(h,0,1,1,b); debug_ADX = b[0]; IndicatorRelease(h);
        }
        bool isMacroDead = (debug_ADX < Consol_H4_ADX_Min);

        // 2. Check H1 Width
        double debug_Width = 0;
        {
            int h = iBands(_Symbol, PERIOD_H1, 20, 0, 2.0, PRICE_CLOSE);
            double u[], l[], m[]; ArraySetAsSeries(u,true); ArraySetAsSeries(l,true); ArraySetAsSeries(m,true);
            CopyBuffer(h,1,1,1,u); CopyBuffer(h,2,1,1,l); CopyBuffer(h,0,1,1,m);
            debug_Width = (u[0] - l[0]) / m[0]; IndicatorRelease(h);
        }
        bool isHourlySqueeze = (debug_Width < Consol_H1_BB_Width);

        // 3. Check M15 Range
        double debug_Range = 0;
        {
            double h[], l[]; ArraySetAsSeries(h,true); ArraySetAsSeries(l,true);
            CopyHigh(_Symbol, PERIOD_M15, 1, 20, h); CopyLow(_Symbol, PERIOD_M15, 1, 20, l);
            debug_Range = (h[ArrayMaximum(h)] - l[ArrayMinimum(l)]) / _Point;
        }
        bool isMicroChop = (debug_Range < Consol_M15_Range_Pts);

        bool forceScalp = (isMacroDead || isHourlySqueeze || isMicroChop);

        // --- DISPLAY DASHBOARD ---
        string dash = "====== üìä NODEZILLA CONSOLIDATION DASHBOARD üìä ======\n";
        dash += StringFormat("H4 Trend (ADX):  %.2f  %s  (Limit: %.2f)\n", debug_ADX, isMacroDead ? "üî¥ DEAD" : "üü¢ ACTIVE", Consol_H4_ADX_Min);
        dash += StringFormat("H1 Volatility:   %.5f  %s  (Limit: %.5f)\n", debug_Width, isHourlySqueeze ? "üî¥ SQUEEZE" : "üü¢ EXPANDED", Consol_H1_BB_Width);
        dash += StringFormat("M15 Range (20):  %.0f pts  %s  (Limit: %.0f)\n", debug_Range, isMicroChop ? "üî¥ CHOPPING" : "üü¢ MOVING", Consol_M15_Range_Pts);
        dash += "\nCURRENT MODE: " + (forceScalp ? "üê¢ SCALP (Consolidation)" : "üêá MAIN (Trending)");
        
        Comment(dash);

        if (Use_Auto_Regime_Switch)
        {
            if (forceScalp)
            {
                // --- CASE 1: CONSOLIDATION (Force Scalp) ---
                string reason = "";
                if(isMacroDead) reason += "[H4 Flat] ";
                if(isHourlySqueeze) reason += "[H1 Squeeze] ";
                if(isMicroChop) reason += "[M15 Box] ";
                
                // Only run scalp if the user actually enabled Scalp Mode in settings
                if(Use_Scalp_Mode) TryScalpEntries();
                
                Comment("üê¢ Mode: CONSOLIDATION (Scalping)\nReason: " + reason);
            }
            else
            {
                // --- CASE 2: TRENDING (Force Main) ---
                // All 3 timeframes agree the market is moving freely!
                TryEntries();
                Comment("üêá Mode: TRENDING (Main Strategy Active)");
            }
        }
        else
        {
             // --- CASE 3: MANUAL OVERRIDE (Run Both) ---
             TryEntries();
             if(Use_Scalp_Mode) TryScalpEntries();
             Comment("‚öôÔ∏è Mode: Manual Settings (Auto-Switch OFF)");
        }
        
        // Update SuperTrend Direction for next tick calculations
        double st_line; int st_dir;
        if(CalcSuperTrend(TF_Trade, ST_ATR_Period, ST_ATR_Mult, 1, st_line, st_dir))
        {
            prevDir_ST = st_dir;
        }
    }
    
    // C. SCALP LOGIC (For faster timeframes)
    static datetime lastScalpBarTime = 0;
    datetime currentScalpBarTime = iTime(_Symbol, TF_Scalp, 0);
    
    if(currentScalpBarTime != lastScalpBarTime)
    {
        lastScalpBarTime = currentScalpBarTime;
        
        // If Auto-Switch is ON, we only run scalp here if we determined it was consolidating above.
        bool shouldScalp = (!Use_Auto_Regime_Switch && Use_Scalp_Mode);
        
        if(Use_Auto_Regime_Switch)
        {
             // Re-check fast to see if we are allowed to scalp
             if (IsMarketConsolidating(PERIOD_H4) || IsMarketConsolidating(PERIOD_H1) || IsMarketConsolidating(PERIOD_M15))
             {
                 shouldScalp = true;
             }
        }

        // Time Filter Check for Scalp specifically
        if (Use_Time_Filter && !IsTradeTime()) shouldScalp = false;

        if (shouldScalp)
        {
             TryScalpEntries();
        }
    }
}
// REPLACEMENT FOR OnDeinit() FUNCTION
void OnDeinit(const int reason)
{
    EventKillTimer();
    
    string deactivationMsg = StringFormat(
                                          "‚ùå <b>Nodezilla101 EA Bot DEACTIVATED</b>\n\n"
                                          "üìä <b>Symbol:</b> %s\n"
                                          "‚è∞ <b>Timeframe:</b> %s\n"
                                          "‚ö° <b>Reason:</b> %s",
                                          _Symbol,
                                          tfstr(_Period),
                                          GetDeinitReason(reason)
                                          );
    SendTG(deactivationMsg);
}

// CORRECTED OnTradeTransaction FUNCTION
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest      &req,
                        const MqlTradeResult       &res)
{
    // Only look for new deals being added or orders being deleted
    if(trans.type != TRADE_TRANSACTION_DEAL_ADD && trans.type != TRADE_TRANSACTION_ORDER_DELETE)
    {
        return;
    }
    
    // --- SECTION 1: A NEW DEAL WAS ADDED (A TRADE WAS OPENED) ---
    if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
    {
        ulong deal = (ulong)trans.deal;
        if(deal == 0) return;
        
        if(!HistorySelect(0, TimeCurrent())) return;
        
        long entryType = (long)HistoryDealGetInteger(deal, DEAL_ENTRY);
        string sym = (string)HistoryDealGetString(deal, DEAL_SYMBOL);
        if(sym != _Symbol) return;
        
        long mg = (long)HistoryDealGetInteger(deal, DEAL_MAGIC);
        if(mg != Magic_Main && mg != Magic_Scalp) return;
        
        // This is a new trade entry
        if(entryType == DEAL_ENTRY_IN)
        {
            long   dType   = (long)HistoryDealGetInteger(deal, DEAL_TYPE);
            string typeStr = (dType==DEAL_TYPE_BUY) ? "BUY" : "SELL";
            string typeEmoji = (dType==DEAL_TYPE_BUY) ? "üìà" : "üìâ";
            double entry   = HistoryDealGetDouble(deal, DEAL_PRICE);
            double lots    = HistoryDealGetDouble(deal, DEAL_VOLUME);
            string cmt     = (string)HistoryDealGetString(deal, DEAL_COMMENT);
            bool   isScalp = (mg == Magic_Scalp);
            string strat   = isScalp ? "Scalp Strategy" : "Main Strategy";
            
            double sl=0.0, tp=0.0;
            ulong posID = (ulong)HistoryDealGetInteger(deal, DEAL_POSITION_ID);
            if(PositionSelectByTicket(posID))
            {
                sl = PositionGetDouble(POSITION_SL);
                tp = PositionGetDouble(POSITION_TP);
            }
            
            // ==================== BUG FIX START ====================
            //
            // We check if this is a scalp trade AND if 'Adjust_All_To_Latest' is on.
            // If so, we call ApplySLTPToAllOpen, which correctly
            // respects the 'Adjust_All_Exclude_Scalps' setting.
            //
            if(isScalp && Adjust_All_To_Latest)
            {
                // Determine direction (+1 for Buy, -1 for Sell)
                int dir = (dType == DEAL_TYPE_BUY) ? +1 : -1;
                
                // Call the correct function that respects 'Adjust_All_Exclude_Scalps'
                ApplySLTPToAllOpen(dir, sl, tp);
            }
            //
            // ===================== BUG FIX END =====================
            
            string execMsg = StringFormat(
                                          "‚úÖ <b>TRADE EXECUTED</b>\n\n"
                                          "üìä <b>Symbol:</b> %s\n"
                                          "%s <b>Type:</b> %s\n"
                                          "üí∞ <b>Entry:</b> %s\n"
                                          "üì¶ <b>Lots:</b> %.2f\n"
                                          "üõë <b>SL:</b> %s\n"
                                          "üéØ <b>TP:</b> %s\n"
                                          "‚ö° <b>Strategy:</b> %s",
                                          _Symbol, typeEmoji, typeStr, DoubleToString(entry, _Digits),
                                          lots, DoubleToString(sl, _Digits), DoubleToString(tp, _Digits), strat
                                          );
            SendTG(execMsg);
            return;
        }
        
        // This is a trade exit
        if(Send_Closed_Trade_Alerts && (entryType==DEAL_ENTRY_OUT || entryType==DEAL_ENTRY_OUT_BY))
        {
            double P    = HistoryDealGetDouble (deal, DEAL_PROFIT);
            double F    = HistoryDealGetDouble (deal, DEAL_FEE);
            double C    = HistoryDealGetDouble (deal, DEAL_COMMISSION);
            double S    = HistoryDealGetDouble (deal, DEAL_SWAP);
            double net  = P + F + C + S;
            double exitPrice = HistoryDealGetDouble(deal, DEAL_PRICE);
            long   dealReason = HistoryDealGetInteger(deal, DEAL_REASON);
            ulong  positionID = (ulong)HistoryDealGetInteger(deal, DEAL_POSITION_ID);
            string dealComment = (string)HistoryDealGetString(deal, DEAL_COMMENT);
            
            double entryPrice = 0.0;
            double tpPrice = 0.0;
            long   originalDealType = -1;
            string entryComment = "";
            
            if (positionID > 0)
            {
                for (int i = (int)HistoryDealsTotal() - 1; i >= 0; i--)
                {
                    ulong d_ticket = HistoryDealGetTicket(i);
                    if (d_ticket == 0) continue;
                    
                    if (HistoryDealGetInteger(d_ticket, DEAL_POSITION_ID) == positionID &&
                        HistoryDealGetInteger(d_ticket, DEAL_ENTRY) == DEAL_ENTRY_IN)
                    {
                        entryPrice = HistoryDealGetDouble(d_ticket, DEAL_PRICE);
                        originalDealType = HistoryDealGetInteger(d_ticket, DEAL_TYPE);
                        entryComment = HistoryDealGetString(d_ticket, DEAL_COMMENT);
                        
                        ulong orderTicket = HistoryDealGetInteger(d_ticket, DEAL_ORDER);
                        if (HistoryOrderSelect(orderTicket))
                        {
                            tpPrice = HistoryOrderGetDouble(orderTicket, ORDER_TP);
                        }
                        break;
                    }
                }
            }
            
            string reason = "Unknown/Other";
            if(dealReason == DEAL_REASON_CLIENT)           reason = "Closed Manually by Client";
            else if(dealReason == DEAL_REASON_EXPERT)      reason = "Closed by EA Logic";
            else if(dealReason == DEAL_REASON_SL)          reason = "Closed by Stop Loss";
            else if(dealReason == DEAL_REASON_TP)          reason = "Closed by Take Profit";
            else if(dealReason == DEAL_REASON_SO)          reason = "Closed by Stop Out";
            else if(dealReason == DEAL_REASON_ROLLOVER)    reason = "Closed due to Rollover";
            else if(dealReason == DEAL_REASON_VMARGIN)     reason = "Closed by Var. Margin";
            else if(dealReason == DEAL_REASON_SPLIT)       reason = "Closed due to Split";
            else if(entryComment == "")                    reason = "Closed Manually (No Comment)";
            string typeStr = (originalDealType == DEAL_TYPE_BUY) ? "BUY" : ((originalDealType == DEAL_TYPE_SELL) ? "SELL" : "Unknown");
            string finalComment = (dealComment != "" && dealComment != "tp" && dealComment != "sl") ? dealComment : entryComment;
            string closeMsg = StringFormat(
                                           "%s <b>POSITION CLOSED</b>\n\n"
                                           "üìä <b>Symbol:</b> %s\n"
                                           "üî¢ <b>Ticket:</b> %I64u\n"
                                           "üìà <b>Type:</b> %s\n"
                                           "üí¨ <b>Comment:</b> %s\n\n"
                                           "‚ñ∂Ô∏è <b>Entry:</b> %s\n"
                                           "‚èπÔ∏è <b>Exit:</b> %s\n"
                                           "üí∞ <b>Profit/Loss:</b> %s%s%.2f\n\n"
                                           "‚ö° <b>Reason:</b> %s",
                                           net >= 0 ? "‚úÖ" : "‚ùå",
                                           _Symbol,
                                           positionID,
                                           typeStr,
                                           finalComment,
                                           DoubleToString(entryPrice, _Digits),
                                           DoubleToString(exitPrice, _Digits),
                                           net >= 0 ? "‚úÖ" : "‚ùå", net >= 0 ? "+" : "", net,
                                           reason
                                           );
            SendTG(closeMsg);
            return;
        }
    }
    // --- SECTION 2: A PENDING ORDER WAS DELETED ---
    else if(trans.type == TRADE_TRANSACTION_ORDER_DELETE)
    {
        if(req.magic == Magic_Main || req.magic == Magic_Scalp)
        {
            if(trans.order_type == ORDER_TYPE_BUY_LIMIT || trans.order_type == ORDER_TYPE_SELL_LIMIT)
            {
                string orderTypeStr = (trans.order_type == ORDER_TYPE_BUY_LIMIT) ? "Buy Limit" : "Sell Limit";
                
                string removeMsg = StringFormat(
                                                "üîµ <b>PENDING ORDER REMOVED</b>\n\n"
                                                "üìä <b>Symbol:</b> %s\n"
                                                "üîµ <b>Type:</b> %s\n"
                                                "üí∞ <b>Price:</b> %s\n"
                                                "‚ö° <b>Reason:</b> Order expired or was canceled.",
                                                _Symbol,
                                                orderTypeStr,
                                                DoubleToString(trans.price, _Digits)
                                                );
                SendTG(removeMsg);
            }
        }
    }
}
//+------------------------------------------------------------------+
//| Smart Consolidation Detector (With Debugging)                    |
//+------------------------------------------------------------------+
bool IsMarketConsolidating(ENUM_TIMEFRAMES timeframe)
{
   // --- 1. H4 STRATEGY: ADX ---
   if(timeframe == PERIOD_H4)
   {
      int handle = iADX(_Symbol, timeframe, 14);
      if(handle == INVALID_HANDLE) return false;
      
      double buffer[]; ArraySetAsSeries(buffer, true);
      if(CopyBuffer(handle, 0, 1, 1, buffer) < 0) { IndicatorRelease(handle); return false; }
      
      double adxValue = buffer[0];
      IndicatorRelease(handle);
      
      // DEBUG PRINT
      // PrintFormat("DEBUG H4 ADX: %.2f (Threshold: %.2f)", adxValue, Consol_H4_ADX_Min);
      
      return (adxValue < Consol_H4_ADX_Min);
   }

   // --- 2. H1 STRATEGY: Bollinger Bandwidth ---
   if(timeframe == PERIOD_H1)
   {
      int handle = iBands(_Symbol, timeframe, 20, 0, 2.0, PRICE_CLOSE);
      if(handle == INVALID_HANDLE) return false;
      
      double upper[], lower[], middle[];
      ArraySetAsSeries(upper, true); ArraySetAsSeries(lower, true); ArraySetAsSeries(middle, true);
      CopyBuffer(handle, 1, 1, 1, upper); CopyBuffer(handle, 2, 1, 1, lower); CopyBuffer(handle, 0, 1, 1, middle);
      IndicatorRelease(handle);
      
      double bandwidth = (upper[0] - lower[0]) / middle[0];
      
      // DEBUG PRINT
      // PrintFormat("DEBUG H1 BB Width: %.5f (Threshold: %.5f)", bandwidth, Consol_H1_BB_Width);

      return (bandwidth < Consol_H1_BB_Width);
   }

   // --- 3. M15 STRATEGY: Box Range ---
   if(timeframe == PERIOD_M15)
   {
      double highs[], lows[];
      ArraySetAsSeries(highs, true); ArraySetAsSeries(lows, true);
      int lookback = 20;
      if(CopyHigh(_Symbol, timeframe, 1, lookback, highs) < 0 || CopyLow(_Symbol, timeframe, 1, lookback, lows) < 0) return false;
      
      double maxHigh = highs[ArrayMaximum(highs)];
      double minLow = lows[ArrayMinimum(lows)];
      double rangePoints = (maxHigh - minLow) / _Point;
      
      // DEBUG PRINT
      // PrintFormat("DEBUG M15 Range: %.0f points (Threshold: %.0f)", rangePoints, Consol_M15_Range_Pts);

      return (rangePoints < Consol_M15_Range_Pts);
   }
   
   return false;
}
//+------------------------------------------------------------------+
//| Custom Optimization Criterion: (Recovery Factor * Profit Factor)
//|                          (With hard filters for DD & PF)
//+------------------------------------------------------------------+
double OnTester()
{
    double netProfit       = TesterStatistics(STAT_PROFIT);
    double drawdownPct     = TesterStatistics(STAT_EQUITY_DDREL_PERCENT);
    double profitFactor    = TesterStatistics(STAT_PROFIT_FACTOR);
    double recoveryFactor  = TesterStatistics(STAT_RECOVERY_FACTOR);
    
    // DEBUG: Print the stats to Journal so you can see why it's 0
    PrintFormat("TEST RESULTS: Profit=%.2f, DD=%.2f%%, PF=%.2f", netProfit, drawdownPct, profitFactor);

    // 1. Filter: Must be profitable
    if (netProfit <= 0.0) return 0.0;

    // 2. Filter: Drawdown (Relaxed to 20% for testing)
    if (drawdownPct > 20.0) return 0.0;
    
    // 3. Filter: Profit Factor (Relaxed to 1.0 for testing)
    if (profitFactor < 1.0) return 0.0;

    // Calculate Score
    if (recoveryFactor == 0) recoveryFactor = 1.0; // Avoid zero mult
    return recoveryFactor * profitFactor;
}
